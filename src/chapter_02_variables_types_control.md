# ç¬¬2ç« ï¼šå˜é‡ã€æ•°æ®ç±»å‹ä¸æ§åˆ¶æµ

## å­¦ä¹ ç›®æ ‡

- æŒæ¡ Rust ä¸­å˜é‡å£°æ˜å’Œä½¿ç”¨çš„åŸºæœ¬è¯­æ³•
- ç†è§£å„ç§æ•°æ®ç±»å‹çš„ç‰¹æ€§å’Œä½¿ç”¨åœºæ™¯
- ç†Ÿç»ƒä½¿ç”¨æ§åˆ¶æµè¯­å¥è¿›è¡Œé€»è¾‘æ§åˆ¶
- å­¦ä¼šå®šä¹‰å’Œè°ƒç”¨å‡½æ•°

---

## 2.1 å˜é‡ä¸å¯å˜æ€§

### 2.1.1 åŸºæœ¬å˜é‡å£°æ˜

åœ¨ Rust ä¸­ï¼Œå˜é‡é€šè¿‡ let å…³é”®å­—å£°æ˜ï¼Œé»˜è®¤æ˜¯ä¸å¯å˜çš„ï¼ˆimmutableï¼‰ã€‚è¿™æ„å‘³ç€ä¸€æ—¦å˜é‡è¢«ç»‘å®šåˆ°ä¸€ä¸ªå€¼ï¼Œä½ å°±ä¸èƒ½å†ä¿®æ”¹å®ƒã€‚è¿™ç§è®¾è®¡æ˜¯ä¸ºäº†ç¡®ä¿ä»£ç çš„å®‰å…¨æ€§å’Œå¯é¢„æµ‹æ€§ï¼Œé¿å…æ„å¤–çš„å‰¯ä½œç”¨ã€‚Rust çš„ç±»å‹ç³»ç»Ÿä¼šè‡ªåŠ¨æ¨æ–­å˜é‡çš„ç±»å‹ï¼Œä½†ä½ ä¹Ÿå¯ä»¥æ˜¾å¼æŒ‡å®šï¼ˆå¦‚ let x: i32 = 5;ï¼‰ã€‚

```rust
// åŸºæœ¬å˜é‡å£°æ˜ï¼ˆä¸å¯å˜ï¼‰
fn variable_basics() {
    let x = 42;                    // æ•´æ•°
    let y = 3.14;                  // æµ®ç‚¹æ•°
    let name = "Rust";             // å­—ç¬¦ä¸²å­—é¢é‡
    let is_rust_awesome = true;    // å¸ƒå°”å€¼
    
    println!("æ•´æ•°: {}", x);
    println!("æµ®ç‚¹æ•°: {}", y);
    println!("å­—ç¬¦ä¸²: {}", name);
    println!("å¸ƒå°”å€¼: {}", is_rust_awesome);
    
    // å˜é‡é®è”½ï¼ˆshadowingï¼‰
    let x = x + 10;                // åˆ›å»ºæ–°çš„ xï¼ŒåŸ x è¢«éšè—
    {
        let x = "shadowed";       // åˆ›å»ºæ–°çš„ xï¼ŒåŸ x è¢«éšè—
        println!("é®è”½ä¸­çš„ x: {}", x);
    }
    println!("é®è”½åçš„ x: {}", x);
}
```

**Result:**

``` shell
æ•´æ•°: 42
æµ®ç‚¹æ•°: 3.14
å­—ç¬¦ä¸²: Rust
å¸ƒå°”å€¼: true
é®è”½ä¸­çš„ x: shadowed
é®è”½åçš„ x: 52
```

**å…³é”®ç‚¹**ï¼š

- ä½¿ç”¨ `let` ç»‘å®šå€¼ã€‚
- å˜é‡ååŒºåˆ†å¤§å°å†™ï¼Œéµå¾ªè›‡å½¢å‘½åæ³•ï¼ˆsnake_caseï¼‰ã€‚
- åœ¨å‡½æ•°æˆ–å—ä½œç”¨åŸŸå†…æœ‰æ•ˆï¼Œè¶…å‡ºä½œç”¨åŸŸåè‡ªåŠ¨é‡Šæ”¾ï¼ˆæ‰€æœ‰æƒç³»ç»Ÿï¼‰ã€‚
  
### 2.1.2 å¯å˜å˜é‡

Rust çš„é»˜è®¤ä¸å¯å˜æ€§å¾ˆä¸¥æ ¼ï¼Œä½†å¦‚æœä½ éœ€è¦ä¿®æ”¹å˜é‡ï¼Œå¯ä»¥ä½¿ç”¨ mut å…³é”®å­—å£°æ˜ä¸ºå¯å˜çš„ï¼ˆmutableï¼‰ã€‚è¿™å…è®¸ä½ é‡æ–°èµ‹å€¼ï¼Œä½†å¿…é¡»åœ¨å£°æ˜æ—¶å°±æŒ‡å®šï¼Œä»¥æ˜ç¡®æ„å›¾ã€‚æ³¨æ„ï¼Œå¯å˜æ€§æ˜¯ä½œç”¨åŸŸå†…çš„ï¼šä¸€ä¸ªå˜é‡åœ¨æ•´ä¸ªä½œç”¨åŸŸå†…è¦ä¹ˆå¯å˜ï¼Œè¦ä¹ˆä¸å¯å˜ï¼Œä¸èƒ½ä¸­é€”æ”¹å˜ã€‚

```rust
fn mutable_variables() {
    // å¯å˜å˜é‡å£°æ˜
    let mut counter = 0;
    println!("åˆå§‹å€¼: {}", counter);
    
    // ä¿®æ”¹å¯å˜å˜é‡
    counter += 1;
    counter *= 2;
    println!("ä¿®æ”¹å: {}", counter);
    
    // å¯å˜å˜é‡çš„å…¸å‹ç”¨é€”
    let mut sum = 0;  // åˆå§‹åŒ–ä¸º 0
    let numbers = vec![1, 2, 3, 4, 5];  // åˆ›å»ºä¸€ä¸ªå‘é‡
    
    for num in numbers {
        sum += num;                // åœ¨å¾ªç¯ä¸­ç´¯ç§¯è®¡ç®—
    }
    
    println!("æ•°åˆ—å’Œ: {}", sum);
}
```

**Result:**

``` shell
åˆå§‹å€¼: 0
ä¿®æ”¹å: 2
æ•°åˆ—å’Œ: 15
```

**å…³é”®ç‚¹**ï¼š

- ä½¿ç”¨ `let mut` å£°æ˜å¯å˜å˜é‡ã€‚
- å¯å˜å˜é‡å¯ä»¥åœ¨å£°æ˜åé‡æ–°èµ‹å€¼ã€‚
- å¯å˜å˜é‡åœ¨å¾ªç¯æˆ–å‡½æ•°ä¸­å¸¸ç”¨ï¼Œä»¥ç´¯ç§¯è®¡ç®—ç»“æœã€‚
- å¯å˜å˜é‡åœ¨ Rust ä¸­æ˜¯è°¨æ…ä½¿ç”¨çš„ï¼Œä»¥é¿å…æ„å¤–ä¿®æ”¹ã€‚
- åªåœ¨éœ€è¦æ—¶ä½¿ç”¨ `mut`ï¼Œä»¥æœ€å°åŒ–å¯å˜æ€§ï¼ˆå‡å°‘ bug é£é™©ï¼‰ã€‚
- åœ¨å€Ÿç”¨è§„åˆ™ä¸‹ï¼Œå¯å˜å€Ÿç”¨ï¼ˆ&mutï¼‰æœ‰ä¸¥æ ¼é™åˆ¶ï¼Œç¡®ä¿çº¿ç¨‹å®‰å…¨ã€‚
- ä½œç”¨åŸŸå†…ï¼Œå˜é‡è¦ä¹ˆå¯å˜ï¼Œè¦ä¹ˆä¸å¯å˜ï¼Œä¸èƒ½ä¸­é€”æ”¹å˜ã€‚

å¯å˜å˜é‡æ˜¯ Rust çµæ´»æ€§çš„å…³é”®ï¼Œä½†ç»“åˆæ‰€æœ‰æƒå’Œå€Ÿç”¨æ£€æŸ¥å™¨ï¼Œä½¿ç”¨æ—¶éœ€å°å¿ƒé¿å…ç¼–è¯‘é”™è¯¯ã€‚

### 2.1.3 å¸¸é‡å£°æ˜

å¸¸é‡é€šè¿‡ const å…³é”®å­—å£°æ˜ï¼Œæ˜¯ä¸å¯å˜çš„ï¼Œä¸”å¿…é¡»åœ¨ç¼–è¯‘æ—¶ç¡®å®šå€¼ï¼ˆä¸èƒ½æ˜¯è¿è¡Œæ—¶è®¡ç®—çš„ï¼‰ã€‚å¸¸é‡æ˜¯å…¨å±€å¯è§çš„ï¼ˆå¦‚æœåœ¨æ¨¡å—é¡¶å±‚å£°æ˜ï¼‰ï¼Œå¹¶åœ¨æ•´ä¸ªç¨‹åºç”Ÿå‘½å‘¨æœŸå†…æœ‰æ•ˆã€‚å®ƒä»¬é€‚åˆå®šä¹‰ä¸å˜çš„é…ç½®æˆ–æ•°å­¦å¸¸æ•°ã€‚ç±»å‹å¿…é¡»æ˜¾å¼æŒ‡å®šï¼Œä¸”ä¸èƒ½æ˜¯ `mut`ã€‚

```rust
// å¸¸é‡å£°æ˜ï¼ˆalways immutable, must have type annotationï¼‰
fn constants_example() {
    const PI: f64 = 3.14159265359;  // æµ®ç‚¹æ•°å¸¸é‡
    const MAX_SIZE: usize = 1000; // æ— ç¬¦å·æ•´æ•°å¸¸é‡
    const GREETING: &str = "Hello, World!"; // å­—ç¬¦ä¸²å¸¸é‡
    
    println!("PI = {}", PI);
    println!("æœ€å¤§å°ºå¯¸: {}", MAX_SIZE);
    println!("é—®å€™è¯­: {}", GREETING);
    
    // å¸¸é‡è¡¨è¾¾å¼
    const AREA: f64 = PI * 10.0 * 10.0;  // åœ†é¢ç§¯å…¬å¼
    println!("åœ†é¢ç§¯: {}", AREA);
}
```

**Result:**

``` shell
PI = 3.14159265359
æœ€å¤§å°ºå¯¸: 1000
é—®å€™è¯­: Hello, World!
åœ†é¢ç§¯: 314.15926535899996
```

**å…³é”®ç‚¹**ï¼š

- ä½¿ç”¨ `const NAME: Type = value;` æ ¼å¼ï¼Œ`NAME` éµå¾ªå¤§å†™è›‡å½¢å‘½åï¼ˆSCREAMING_SNAKE_CASEï¼‰ã€‚
- å€¼å¿…é¡»æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼ˆå¦‚å­—é¢é‡ã€ç®€å•è®¡ç®—ï¼‰ï¼Œä¸èƒ½ä¾èµ–è¿è¡Œæ—¶è¾“å…¥ã€‚
- é™æ€å¸¸é‡ï¼ˆ`static`ï¼‰ç±»ä¼¼ï¼Œä½†æœ‰é¢å¤–ç”Ÿå‘½å‘¨æœŸè€ƒè™‘ï¼›`const` æ›´å¸¸è§ç”¨äºç®€å•å€¼ã€‚
- å¸¸é‡åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œæå‡ä»£ç çš„å¯ç»´æŠ¤æ€§å’Œæ€§èƒ½ã€‚
- å¸¸é‡ä¸å¯å˜ï¼Œé€‚ç”¨äºå®šä¹‰ä¸å˜çš„äº‹å®æˆ–é…ç½®ã€‚

å¸¸é‡æå‡äº†ä»£ç çš„å¯ç»´æŠ¤æ€§ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ä¸å¯å˜çš„â€œäº‹å®â€ï¼Œå¹¶åœ¨ç¼–è¯‘æ—¶ä¼˜åŒ–ã€‚

---

## 2.2 åŸºç¡€æ•°æ®ç±»å‹

Rust çš„åŸºç¡€æ•°æ®ç±»å‹åˆ†ä¸ºæ ‡é‡ç±»å‹ï¼ˆscalar typesï¼‰å’Œå¤åˆç±»å‹ï¼ˆcompound typesï¼‰ã€‚æ ‡é‡ç±»å‹è¡¨ç¤ºå•ä¸€å€¼ï¼Œå¤åˆç±»å‹å¯åŒ…å«å¤šä¸ªå€¼ã€‚è¿™äº›ç±»å‹åœ¨ç¼–è¯‘æ—¶ç¡®å®šå¤§å°ï¼Œç¡®ä¿å†…å­˜å®‰å…¨å’Œæ€§èƒ½ã€‚

### æ ‡é‡ç±»å‹ï¼ˆScalarsï¼‰

- **æ•´æ•°ï¼ˆIntegersï¼‰**ï¼šæœ‰ç¬¦å·ï¼ˆi8, i16, i32, i64, isizeï¼‰å’Œæ— ç¬¦å·ï¼ˆu8, u16, u32, u64, usizeï¼‰ã€‚é»˜è®¤ i32ã€‚
- **æµ®ç‚¹æ•°ï¼ˆFloatsï¼‰**ï¼šf32ï¼ˆå•ç²¾åº¦ï¼‰å’Œ f64ï¼ˆåŒç²¾åº¦ï¼Œé»˜è®¤ï¼‰ã€‚
- **å¸ƒå°”ï¼ˆBooleanï¼‰**ï¼šboolï¼Œä»… true æˆ– falseã€‚
- **å­—ç¬¦ï¼ˆCharacterï¼‰**ï¼šcharï¼ŒUnicode æ ‡é‡å€¼ï¼ˆå¦‚ 'a'ï¼‰ã€‚

### å¤åˆç±»å‹ï¼ˆCompoundsï¼‰

- **å…ƒç»„ï¼ˆTuplesï¼‰**ï¼šå›ºå®šå¤§å°çš„å¼‚æ„é›†åˆï¼Œå¦‚ `(i32, bool)`ã€‚
- **æ•°ç»„ï¼ˆArraysï¼‰**ï¼šå›ºå®šé•¿åº¦ã€åŒæ„å…ƒç´ ï¼Œå¦‚ `[i32; 5]`ï¼ˆ5 ä¸ª i32ï¼‰ã€‚

### 2.2.1 æ•´æ•°ç±»å‹

```rust
fn integer_types() {
    // æœ‰ç¬¦å·æ•´æ•°
    let i8_val: i8 = -128;          // èŒƒå›´: -128 åˆ° 127 
    let i16_val: i16 = -32768;      // èŒƒå›´: -32768 åˆ° 32767
    let i32_val: i32 = -2147483648; // é»˜è®¤çš„æ•´æ•°ç±»å‹
    let i64_val: i64 = -9223372036854775808;
    let i128_val: i128 = -170141183460469231731687303715884105728;
    
    // æ— ç¬¦å·æ•´æ•°
    let u8_val: u8 = 255;           // èŒƒå›´: 0 åˆ° 255
    let u16_val: u16 = 65535;
    let u32_val: u32 = 4294967295;
    let u64_val: u64 = 18446744073709551615;
    let u128_val: u128 = 340282366920938463463374607431768211455;
    
    // å¹³å°ç›¸å…³æ•´æ•°ç±»å‹
    let isize: isize = -1;          // å¹³å°ç›¸å…³å¤§å°
    let usize: usize = 1;           // å¹³å°ç›¸å…³å¤§å°
    
    // æ•°å€¼å­—é¢é‡
    let decimal = 98_222;           // åè¿›åˆ¶ï¼ˆå¯ç”¨ä¸‹åˆ’çº¿åˆ†éš”ï¼‰
    let hex = 0xff;                 // åå…­è¿›åˆ¶
    let octal = 0o77;               // å…«è¿›åˆ¶
    let binary = 0b1111_0000;       // äºŒè¿›åˆ¶
    let byte = b'A';                // å­—èŠ‚å­—ç¬¦ï¼ˆä»… u8ï¼‰
    
    println!("æ•´æ•°å€¼: {}, {}, {}, {}", decimal, hex, octal, binary);
}
```

**Result:**

```shell
æ•´æ•°å€¼: 98222, 255, 63, 240
```

**å…³é”®ç‚¹ï¼š**

- Rust ä¸­çš„æ•´æ•°ç±»å‹æœ‰ç¬¦å·å’Œæ— ç¬¦å·ï¼Œæœ‰ç¬¦å·æ•´æ•°å¯ä»¥è¡¨ç¤ºè´Ÿæ•°ï¼Œæ— ç¬¦å·æ•´æ•°åªèƒ½è¡¨ç¤ºéè´Ÿæ•°ã€‚
- Rust æä¾›äº†å¤šç§æ•´æ•°ç±»å‹ï¼ŒåŒ…æ‹¬ 8 ä½ã€16 ä½ã€32 ä½ã€64 ä½å’Œ 128 ä½çš„æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´æ•°ã€‚
- Rust è¿˜æä¾›äº†å¹³å°ç›¸å…³çš„æ•´æ•°ç±»å‹ï¼Œå¦‚ `isize` å’Œ `usize`ï¼Œå®ƒä»¬çš„å¤§å°å–å†³äºè¿è¡Œç¨‹åºçš„è®¡ç®—æœºæ¶æ„ã€‚
- Rust æ”¯æŒæ•°å€¼å­—é¢é‡çš„å¤šç§è¡¨ç¤ºæ–¹å¼ï¼ŒåŒ…æ‹¬åè¿›åˆ¶ã€åå…­è¿›åˆ¶ã€å…«è¿›åˆ¶å’ŒäºŒè¿›åˆ¶ã€‚
- Rust ä¸­çš„æ•´æ•°ç±»å‹éƒ½æœ‰å›ºå®šçš„èŒƒå›´ï¼Œè¶…è¿‡èŒƒå›´ä¼šå¯¼è‡´æº¢å‡ºé”™è¯¯ã€‚
- Rust æä¾›äº† `std::num` æ¨¡å—ä¸­çš„å‡½æ•°æ¥å¤„ç†æ•´æ•°æº¢å‡ºï¼Œå¦‚ `wrapping_add`ã€`wrapping_sub`ã€`wrapping_mul` ç­‰ã€‚
- ...
  
### 2.2.2 æµ®ç‚¹ç±»å‹

```rust
fn float_types() {
    let f32_val: f32 = 3.141592653589793; // 32ä½æµ®ç‚¹
    let f64_val: f64 = 3.141592653589793; // 64ä½æµ®ç‚¹ï¼ˆé»˜è®¤ï¼‰

    // ç‰¹æ®Šå€¼
    let infinity = f32::INFINITY;
    let neg_infinity = f32::NEG_INFINITY;
    let not_a_number = f32::NAN;

    println!("f32: {}", f32_val);
    println!("f64: {}", f64_val);
    println!("æ— ç©·å¤§: {}", infinity);
    println!("è´Ÿæ— ç©·å¤§: {}", neg_infinity);
    println!("éæ•°å­—: {}", not_a_number);

    // æ•°å­¦è¿ç®—
    let result = f32::sqrt(2.0);
    println!("âˆš2 = {}", result);

    // æ¯”è¾ƒè¿ç®—
    let x: f64 = 1.0;   //å¿…é¡»æ˜¾å¼å£°æ˜ç±»å‹ï¼Œå¦åˆ™ç¼–è¯‘å™¨æ— æ³•æ¨æ–­
    let y: f64 = 0.1 + 0.1 + 0.1 + 0.1 + 0.1; //å¿…é¡»æ˜¾å¼å£°æ˜ç±»å‹ï¼Œå¦åˆ™ç¼–è¯‘å™¨æ— æ³•æ¨æ–­
    println!("x == y: {}", x == y); // é¿å…ç›´æ¥æ¯”è¾ƒæµ®ç‚¹æ•°
    println!("(x - y).abs() < 1e-10: {}", (x - y).abs() < 1e-10);
}
```

**Result:**

```shell
f32: 3.1415927
f64: 3.141592653589793
æ— ç©·å¤§: inf
è´Ÿæ— ç©·å¤§: -inf
éæ•°å­—: NaN
âˆš2 = 1.4142135
x == y: false
(x - y).abs() < 1e-10: false
```

**å…³é”®ç‚¹ï¼š**

- Rust æä¾›äº†ä¸¤ç§æµ®ç‚¹ç±»å‹ï¼šf32 å’Œ f64ï¼Œåˆ†åˆ«å ç”¨ 32 ä½å’Œ 64 ä½å†…å­˜ã€‚
- æµ®ç‚¹æ•°å¯ä»¥è¡¨ç¤ºç‰¹æ®Šå€¼ï¼Œå¦‚æ— ç©·å¤§ã€è´Ÿæ— ç©·å¤§å’Œéæ•°å­—ï¼ˆNaNï¼‰ã€‚
- æµ®ç‚¹æ•°è¿ç®—å¯èƒ½ä¼šäº§ç”Ÿä¸ç²¾ç¡®çš„ç»“æœï¼Œå› æ­¤å»ºè®®é¿å…ç›´æ¥æ¯”è¾ƒæµ®ç‚¹æ•°ï¼Œè€Œæ˜¯æ¯”è¾ƒå®ƒä»¬çš„å·®å€¼æ˜¯å¦åœ¨å¯æ¥å—èŒƒå›´å†…ã€‚
- æµ®ç‚¹æ•°è¿ç®—ç¬¦åŒ…æ‹¬åŠ æ³•ï¼ˆ+ï¼‰ã€å‡æ³•ï¼ˆ-ï¼‰ã€ä¹˜æ³•ï¼ˆ*ï¼‰ã€é™¤æ³•ï¼ˆ/ï¼‰å’Œå–ä½™ï¼ˆ%ï¼‰ã€‚
- æµ®ç‚¹æ•°å‡½æ•°åŒ…æ‹¬å¹³æ–¹æ ¹ï¼ˆsqrtï¼‰ã€æŒ‡æ•°ï¼ˆexpï¼‰ã€å¯¹æ•°ï¼ˆlogï¼‰ã€ä¸‰è§’å‡½æ•°ç­‰ã€‚
- æµ®ç‚¹æ•°ç±»å‹å¯ä»¥ä¸æ•´æ•°ç±»å‹è¿›è¡Œæ··åˆè¿ç®—ï¼Œä½†ç»“æœç±»å‹å°†è‡ªåŠ¨æå‡ä¸ºæµ®ç‚¹æ•°ç±»å‹ã€‚
- æµ®ç‚¹æ•°ç±»å‹å¯ä»¥ä¸å¸ƒå°”ç±»å‹è¿›è¡Œæ··åˆè¿ç®—ï¼Œä½†ç»“æœç±»å‹å°†è‡ªåŠ¨æå‡ä¸ºå¸ƒå°”ç±»å‹ã€‚
- æµ®ç‚¹æ•°ç±»å‹å¯ä»¥ä¸å­—ç¬¦ä¸²ç±»å‹è¿›è¡Œæ··åˆè¿ç®—ï¼Œä½†ç»“æœç±»å‹å°†è‡ªåŠ¨æå‡ä¸ºå­—ç¬¦ä¸²ç±»å‹ã€‚
- ...

### 2.2.3 å¸ƒå°”ç±»å‹

```rust
fn boolean_types() {
    let is_learning_rust = true;
    let is_difficult = false;

    // æ¡ä»¶è¡¨è¾¾å¼
    let message = if is_learning_rust {
        "Keep going!"
    } else {
        "Try harder!"
    };

    // å¸ƒå°”é€»è¾‘
    let both_true = is_learning_rust && !is_difficult;
    let either_or = is_learning_rust || is_difficult;

    println!("{} {}", message, both_true);
    println!("Either learning or difficult: {}", either_or);

    // æ¨¡å¼åŒ¹é…ä¸­çš„å¸ƒå°”
    match (is_learning_rust, is_difficult) {
        (true, false) => println!("Perfect learning situation!"),
        (true, true) => println!("Challenging but rewarding!"),
        (false, _) => println!("Maybe try something else?"),
    }
}
```

**Result:**

```shell
Keep going! true
Either learning or difficult: true
Perfect learning situation!
```

**å…³é”®ç‚¹ï¼š**

- å¸ƒå°”ç±»å‹åªæœ‰ä¸¤ä¸ªå€¼ï¼štrue å’Œ falseã€‚
- å¸ƒå°”ç±»å‹å¯ä»¥ä¸æ•´æ•°ç±»å‹è¿›è¡Œæ··åˆè¿ç®—ï¼Œä½†ç»“æœç±»å‹å°†è‡ªåŠ¨æå‡ä¸ºæ•´æ•°ç±»å‹ã€‚
- å¸ƒå°”ç±»å‹å¯ä»¥ä¸å­—ç¬¦ä¸²ç±»å‹è¿›è¡Œæ··åˆè¿ç®—ï¼Œä½†ç»“æœç±»å‹å°†è‡ªåŠ¨æå‡ä¸ºå­—ç¬¦ä¸²ç±»å‹ã€‚

### 2.2.4 å­—ç¬¦ç±»å‹

Rust ä¸­çš„â€œå­—ç¬¦â€æŒ‡çš„æ˜¯ Unicode æ ‡é‡å€¼ï¼ˆUnicode scalar valueï¼‰ï¼Œé€šè¿‡ chars() æ–¹æ³•è·å–ã€‚å®ƒä¸æ˜¯å›ºå®šå¤§å°çš„å­—èŠ‚ï¼Œè€Œæ˜¯é€»è¾‘ä¸Šçš„å­—ç¬¦å•ä½ã€‚

å­—ç¬¦éœ€è¦ä½¿ç”¨å•å¼•å·åŒ…è£¹ï¼Œå¹¶ä¸”åªèƒ½è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ã€‚
å­—ç¬¦ä¸²åº•å±‚æ˜¯å­—èŠ‚æ•°ç»„ï¼ˆ[u8]ï¼‰ï¼Œå¯ä»¥é€šè¿‡ as_bytes() è·å–è§†å›¾ã€‚

æ³¨æ„ ï¼šå­—èŠ‚æ“ä½œé«˜æ•ˆï¼Œä½†éœ€å°å¿ƒï¼šåˆ‡ç‰‡å­—èŠ‚å¯èƒ½æˆªæ–­å­—ç¬¦ï¼Œå¯¼è‡´æ— æ•ˆ UTF-8ã€‚

```rust
fn character_types() {
    let c1 = 'z';                          // å•ä¸ªå­—ç¬¦
    let c2 = 'â„¤';                          // Unicode å­—ç¬¦
    let c3 = 'ğŸ˜Š';                         // è¡¨æƒ…ç¬¦å·
    
    println!("å­—ç¬¦: {}, {}, {}", c1, c2, c3);
    
    // è½¬ä¹‰å­—ç¬¦
    let newline = '\n';
    let tab = '\t';
    let quote = '\'';
    let backslash = '\\';
    
    // å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦
    let string = "Hello, ä¸–ç•Œ! ğŸŒ";
    for (index, char) in string.chars().enumerate() {
        println!("å­—ç¬¦ {}: {}", index, char);
    }
    
    // è·å–å­—èŠ‚
    let bytes = string.as_bytes();
    println!("å­—ç¬¦ä¸²é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰: {}", bytes.len());
}
```

**Result:**

```shell
å­—ç¬¦: z, â„¤, ğŸ˜Š
å­—ç¬¦ 0: H
å­—ç¬¦ 1: e
å­—ç¬¦ 2: l
å­—ç¬¦ 3: l
å­—ç¬¦ 4: o
å­—ç¬¦ 5: ,
å­—ç¬¦ 6:
å­—ç¬¦ 7: ä¸–
å­—ç¬¦ 8: ç•Œ
å­—ç¬¦ 9: !
å­—ç¬¦ 10:
å­—ç¬¦ 11: ğŸŒ
å­—ç¬¦ä¸²é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰: 19
```

**å…³é”®ç‚¹ï¼š**

- å­—ç¬¦ç±»å‹æ˜¯ Unicode æ ‡é‡å€¼ï¼Œå¯ä»¥è¡¨ç¤ºä»»ä½•å­—ç¬¦ã€‚
- å­—ç¬¦ä¸²æ˜¯å­—èŠ‚æ•°ç»„ï¼Œå¯ä»¥é€šè¿‡ as_bytes() è·å–å­—èŠ‚è§†å›¾ã€‚
- å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦å¯ä»¥é€šè¿‡ chars() æ–¹æ³•è·å–ï¼Œå¹¶ä½¿ç”¨ enumerate() æ–¹æ³•éå†ã€‚
- å­—ç¬¦ä¸²é•¿åº¦æ˜¯å­—èŠ‚é•¿åº¦ï¼Œè€Œä¸æ˜¯å­—ç¬¦é•¿åº¦ã€‚
- å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦å¯èƒ½è¢«æˆªæ–­ï¼Œå¯¼è‡´æ— æ•ˆ UTF-8ã€‚
- å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦å¯ä»¥é€šè¿‡ chars() æ–¹æ³•è·å–ï¼Œå¹¶ä½¿ç”¨ enumerate() æ–¹æ³•éå†ã€‚
- ...  

---

## 2.3 å¤åˆæ•°æ®ç±»å‹ï¼šå…ƒç»„å’Œæ•°ç»„

### 2.3.1 å…ƒç»„ï¼ˆTupleï¼‰

å…ƒç»„æ˜¯å›ºå®šé•¿åº¦çš„æœ‰åºé›†åˆï¼Œå¯ä»¥åŒ…å«ä¸åŒç±»å‹çš„å…ƒç´ ã€‚åˆ›å»ºåé•¿åº¦ä¸å¯å˜ï¼Œä½†å†…éƒ¨å…ƒç´ å¯ä»¥æ˜¯éåŒè´¨çš„ã€‚

#### å…ƒç»„åŸºç¡€æ“ä½œ

```rust
fn tuple_basics() {
    // åˆ›å»ºå…ƒç»„
    let tup: (i32, f64, u8) = (500, 6.4, 1);
    let tup2 = (42, "Hello", true);
    
    // è®¿é—®å…ƒç»„å…ƒç´ ï¼ˆä½¿ç”¨ç´¢å¼•ï¼‰
    let x = tup.0;  // 500
    let y = tup.1;  // 6.4
    let z = tup.2;  // 1
    
    println!("å…ƒç»„å€¼: ({}, {}, {})", x, y, z);
    
    // è§£æ„èµ‹å€¼ï¼ˆæ¨¡å¼åŒ¹é…ï¼‰
    let (a, b, c) = tup;
    println!("è§£æ„åçš„å€¼: a={}, b={}, c={}", a, b, c);
    
    // å•ä¸ªå…ƒç´ çš„å…ƒç»„ï¼ˆæ³¨æ„é€—å·ï¼‰
    let single_tuple: (i32,) = (5,);
    let single_value = single_tuple.0;
    println!("å•ä¸ªå…ƒç´ å…ƒç»„: ({}, {})", single_value, single_tuple.0);
}
```

**Result:**

```shell
å…ƒç»„å€¼: (500, 6.4, 1)
è§£æ„åçš„å€¼: a=500, b=6.4, c=1
å•ä¸ªå…ƒç´ å…ƒç»„: (5, 5)
```

**å…³é”®ç‚¹ï¼š**

- å…ƒç»„æ˜¯å›ºå®šé•¿åº¦çš„æœ‰åºé›†åˆï¼Œå¯ä»¥åŒ…å«ä¸åŒç±»å‹çš„å…ƒç´ ã€‚
- å…ƒç»„å¯ä»¥é€šè¿‡ç´¢å¼•è®¿é—®å…ƒç´ ï¼Œç´¢å¼•ä» 0 å¼€å§‹ã€‚
- å…ƒç»„å¯ä»¥ä½¿ç”¨è§£æ„èµ‹å€¼å°†å…ƒç´ èµ‹å€¼ç»™å˜é‡ã€‚
- å•ä¸ªå…ƒç´ çš„å…ƒç»„éœ€è¦ä½¿ç”¨é€—å·ï¼Œå¦åˆ™ä¼šè¢«è§£æä¸ºè¡¨è¾¾å¼ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºå‡½æ•°è¿”å›å¤šä¸ªå€¼ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºæ¨¡å¼åŒ¹é…ï¼Œå°†å…ƒç»„ä¸­çš„å…ƒç´ èµ‹å€¼ç»™å˜é‡ã€‚
- ...

#### å®ç”¨å…ƒç»„ç¤ºä¾‹

```rust
fn practical_tuples() {
    // å‡½æ•°è¿”å›å¤šä¸ªå€¼
    let result = divide_and_remainder(17, 5);
    let (quotient, remainder) = result;
    println!("17 é™¤ä»¥ 5 çš„å•†å’Œä½™æ•°: {}, {}", quotient, remainder);
    
    // ä½¿ç”¨è§£æ„ç›´æ¥è·å–ç»“æœ
    let (sum, product) = calculate_sum_product(10, 20);
    println!("å’Œ: {}, ç§¯: {}", sum, product);
    
    // å­˜å‚¨æ··åˆç±»å‹çš„æ•°æ®
    let person_info = ("å¼ ä¸‰", 25, 175.5, true);
    let (name, age, height, is_student) = person_info;
    println!("{}ä»Šå¹´{}å²ï¼Œèº«é«˜{:.1}cmï¼ŒçŠ¶æ€ï¼š{}", name, age, height, 
             if is_student { "å­¦ç”Ÿ" } else { "éå­¦ç”Ÿ" });
    
    // åµŒå¥—å…ƒç»„
    let nested_tuple = (1, (2, 3), 4);
    let inner_tuple = nested_tuple.1;
    let first_inner = inner_tuple.0;  // 2
    println!("åµŒå¥—å…ƒç»„ä¸­çš„å€¼: {}", first_inner);
}

// è¿”å›å…ƒç»„çš„å‡½æ•°ç¤ºä¾‹
fn divide_and_remainder(dividend: i32, divisor: i32) -> (i32, i32) {
    let quotient = dividend / divisor;
    let remainder = dividend % divisor;
    (quotient, remainder)
}

fn calculate_sum_product(a: i32, b: i32) -> (i32, i32) {
    (a + b, a * b)
}
```

**Resultï¼š**

```shell
17 é™¤ä»¥ 5 çš„å•†å’Œä½™æ•°: 3, 2
å’Œ: 30, ç§¯: 200
å¼ ä¸‰ä»Šå¹´25å²ï¼Œèº«é«˜175.5cmï¼ŒçŠ¶æ€ï¼šå­¦ç”Ÿ
åµŒå¥—å…ƒç»„ä¸­çš„å€¼: 2
```

#### å…ƒç»„åœ¨æ¨¡å¼åŒ¹é…ä¸­çš„åº”ç”¨

```rust
fn tuple_pattern_matching() {
    let coordinates = (10, 20);
    
    match coordinates {
        (0, 0) => println!("åŸç‚¹"),
        (x, 0) => println!("åœ¨Xè½´ä¸Šï¼ŒXåæ ‡: {}", x),
        (0, y) => println!("åœ¨Yè½´ä¸Šï¼ŒYåæ ‡: {}", y),
        (x, y) => println!("åæ ‡ç‚¹: ({}, {})", x, y),
    }
    
    // åŒ…å«æ¡ä»¶å®ˆå«çš„æ¨¡å¼
    let point = (15, 30);
    match point {
        (x, y) if x == y => println!("åœ¨å¯¹è§’çº¿ä¸Š: ({}, {})", x, y),
        (x, y) if x + y == 45 => println!("åæ ‡å’Œä¸º45: ({}, {})", x, y),
        (x, y) => println!("ä¸€èˆ¬åæ ‡: ({}, {})", x, y),
    }
    
    // è§£æ„å‡½æ•°å‚æ•°
    let (name, age) = get_person_info();
    println!("ä¸ªäººä¿¡æ¯: {}ï¼Œ{}å²", name, age);
}

fn get_person_info() -> (&'static str, u32) {
    ("æå››", 30)
}
```

**Resultï¼š**

```shell
åæ ‡ç‚¹: (10, 20)
åæ ‡å’Œä¸º45: (15, 30)
ä¸ªäººä¿¡æ¯: æå››ï¼Œ30å²
```

**å…³é”®ç‚¹ï¼š**

- å…ƒç»„å¯ä»¥åŒ…å«ä¸åŒç±»å‹çš„å…ƒç´ ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºæ¨¡å¼åŒ¹é…ï¼Œä»¥æå–å’Œæ“ä½œå…ƒç»„ä¸­çš„å€¼ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºå‡½æ•°è¿”å›å€¼ï¼Œä»¥è¿”å›å¤šä¸ªå€¼ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºè§£æ„èµ‹å€¼ï¼Œä»¥å°†å…ƒç»„ä¸­çš„å€¼åˆ†é…ç»™å¤šä¸ªå˜é‡ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºæ¨¡å¼åŒ¹é…ä¸­çš„æ¡ä»¶å®ˆå«ï¼Œä»¥æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒçš„ä»£ç å—ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºå‡½æ•°å‚æ•°ï¼Œä»¥ä¼ é€’å¤šä¸ªå€¼ç»™å‡½æ•°ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºè§£æ„å‡½æ•°å‚æ•°ï¼Œä»¥å°†å‡½æ•°å‚æ•°ä¸­çš„å€¼åˆ†é…ç»™å¤šä¸ªå˜é‡ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºæ¨¡å¼åŒ¹é…ä¸­çš„æ¡ä»¶å®ˆå«ï¼Œä»¥æ ¹æ®æ¡ä»¶æ‰§è¡Œä¸åŒçš„ä»£ç å—ã€‚
- å…ƒç»„å¯ä»¥ç”¨äºå‡½æ•°è¿”å›å€¼ï¼Œä»¥è¿”å›å¤šä¸ªå€¼ç»™è°ƒç”¨è€…ã€‚
- ...

### 2.3.2 æ•°ç»„ï¼ˆArrayï¼‰

æ•°ç»„æ˜¯å›ºå®šé•¿åº¦çš„ç›¸åŒç±»å‹å…ƒç´ çš„é›†åˆã€‚æ•°ç»„é•¿åº¦åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œä¸èƒ½åŠ¨æ€å¢é•¿ã€‚

#### æ•°ç»„åŸºç¡€æ“ä½œ

```rust
fn array_basics() {
    // æ•°ç»„å£°æ˜å’Œåˆå§‹åŒ–
    let numbers: [i32; 5] = [1, 2, 3, 4, 5];
    let floats = [3.14, 2.71, 1.41, 1.73];  // ç±»å‹æ¨å¯¼
    let chars = ['R', 'u', 's', 't'];       // å­—ç¬¦æ•°ç»„
    
    // è®¿é—®æ•°ç»„å…ƒç´ 
    let first = numbers[0];
    let last = numbers[4];
    println!("ç¬¬ä¸€ä¸ªå…ƒç´ : {}, æœ€åä¸€ä¸ªå…ƒç´ : {}", first, last);
    
    // æ•°ç»„é•¿åº¦
    println!("numbersæ•°ç»„é•¿åº¦: {}", numbers.len());
    
    // åˆå§‹åŒ–ç›¸åŒå€¼çš„æ•°ç»„
    let repeated = [0; 10];  // é•¿åº¦ä¸º10çš„æ•°ç»„ï¼Œæ‰€æœ‰å…ƒç´ éƒ½æ˜¯0
    println!("é‡å¤å€¼æ•°ç»„é•¿åº¦: {}", repeated.len());
    
    // éå†æ•°ç»„
    for (index, &value) in numbers.iter().enumerate() {
        println!("numbers[{}] = {}", index, value);
    }
}
```

**Resultï¼š**

```shell
ç¬¬ä¸€ä¸ªå…ƒç´ : 1, æœ€åä¸€ä¸ªå…ƒç´ : 5
numbersæ•°ç»„é•¿åº¦: 5
é‡å¤å€¼æ•°ç»„é•¿åº¦: 10
numbers[0] = 1
numbers[1] = 2
numbers[2] = 3
numbers[3] = 4
numbers[4] = 5
```

**å…³é”®ç‚¹ï¼š**

- æ•°ç»„é•¿åº¦åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼Œä¸èƒ½åŠ¨æ€å¢é•¿ã€‚
- æ•°ç»„å…ƒç´ ç±»å‹ç›¸åŒã€‚
- æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ç´¢å¼•è®¿é—®ã€‚
- æ•°ç»„é•¿åº¦å¯ä»¥é€šè¿‡ `len()` æ–¹æ³•è·å–ã€‚
- æ•°ç»„å¯ä»¥åˆå§‹åŒ–ä¸ºç›¸åŒå€¼ã€‚
- æ•°ç»„å¯ä»¥éå†ã€‚
- æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ `iter()` æ–¹æ³•è·å–è¿­ä»£å™¨ï¼Œç„¶åä½¿ç”¨ `enumerate()` æ–¹æ³•è·å–ç´¢å¼•å’Œå€¼ã€‚
- æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ `&` ç¬¦å·è·å–å¼•ç”¨ï¼Œä»¥é¿å…æ‰€æœ‰æƒè½¬ç§»ã€‚
- æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ `iter_mut()` æ–¹æ³•è·å–å¯å˜å¼•ç”¨ï¼Œä»¥ä¿®æ”¹æ•°ç»„å…ƒç´ ã€‚
- æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ `get()` æ–¹æ³•è·å–å¯å˜å¼•ç”¨ï¼Œä»¥ä¿®æ”¹æ•°ç»„å…ƒç´ ã€‚
- æ•°ç»„å…ƒç´ å¯ä»¥é€šè¿‡ `get_mut()` æ–¹æ³•è·å–å¯å˜å¼•ç”¨ï¼Œä»¥ä¿®æ”¹æ•°ç»„å…ƒç´ ã€‚
- ...

#### æ•°ç»„ä¸å¾ªç¯

```rust
fn array_loops() {
    let arr = [10, 20, 30, 40, 50];
    let mut sum = 0;
    
    // æ–¹æ³•1: ä½¿ç”¨ç´¢å¼•å¾ªç¯
    let len = arr.len();
    for i in 0..len {
        sum += arr[i];
        println!("æ·»åŠ  arr[{}] = {}, å½“å‰æ€»å’Œ: {}", i, arr[i], sum);
    }
    println!("æ•°ç»„æ€»å’Œ: {}", sum);
    
    // æ–¹æ³•2: ç›´æ¥éå†å…ƒç´ ï¼ˆæ›´å®‰å…¨ï¼‰
    let mut sum2 = 0;
    for &value in &arr {
        sum2 += value;
        println!("å…ƒç´ å€¼: {}", value);
    }
    println!("é‡æ–°è®¡ç®—çš„æ€»å’Œ: {}", sum2);
    
    // æ–¹æ³•3: enumerateéå†
    for (i, &value) in arr.iter().enumerate() {
        println!("ç´¢å¼• {}: å€¼ {}", i, value);
    }
}
```

**Resultï¼š**

```shell
æ·»åŠ  arr[0] = 10, å½“å‰æ€»å’Œ: 10
æ·»åŠ  arr[1] = 20, å½“å‰æ€»å’Œ: 30
æ·»åŠ  arr[2] = 30, å½“å‰æ€»å’Œ: 60
æ·»åŠ  arr[3] = 40, å½“å‰æ€»å’Œ: 100
æ·»åŠ  arr[4] = 50, å½“å‰æ€»å’Œ: 150
æ•°ç»„æ€»å’Œ: 150
å…ƒç´ å€¼: 10
å…ƒç´ å€¼: 20
å…ƒç´ å€¼: 30
å…ƒç´ å€¼: 40
å…ƒç´ å€¼: 50
é‡æ–°è®¡ç®—çš„æ€»å’Œ: 150
ç´¢å¼• 0: å€¼ 10
ç´¢å¼• 1: å€¼ 20
ç´¢å¼• 2: å€¼ 30
ç´¢å¼• 3: å€¼ 40
ç´¢å¼• 4: å€¼ 50
```

**å…³é”®ç‚¹ï¼š**

- ä½¿ç”¨ `&` ç¬¦å·è·å–ä¸å¯å˜å¼•ç”¨ï¼Œä»¥éå†æ•°ç»„å…ƒç´ ã€‚
- ä½¿ç”¨ `iter()` æ–¹æ³•è·å–ä¸å¯å˜å¼•ç”¨ï¼Œä»¥éå†æ•°ç»„å…ƒç´ ã€‚
- ä½¿ç”¨ `iter_mut()` æ–¹æ³•è·å–å¯å˜å¼•ç”¨ï¼Œä»¥ä¿®æ”¹æ•°ç»„å…ƒç´ ã€‚
- ä½¿ç”¨ `enumerate()` æ–¹æ³•è·å–ç´¢å¼•å’Œå€¼ï¼Œä»¥éå†æ•°ç»„å…ƒç´ ã€‚
- ...

#### å¤šç»´æ•°ç»„

```rust
fn multidimensional_arrays() {
    // äºŒç»´æ•°ç»„
    let matrix: [[i32; 3]; 2] = [
        [1, 2, 3],
        [4, 5, 6],
    ];
    
    println!("çŸ©é˜µå†…å®¹:");
    for (i, row) in matrix.iter().enumerate() {
        for (j, &value) in row.iter().enumerate() {
            print!("matrix[{}][{}] = {}  ", i, j, value);
        }
        println!();
    }
    
    // è®¿é—®äºŒç»´æ•°ç»„å…ƒç´ 
    let element = matrix[1][2];  // ç¬¬äºŒè¡Œç¬¬ä¸‰åˆ—çš„å€¼: 6
    println!("matrix[1][2] = {}", element);
    
    // ä¸‰ç»´æ•°ç»„ç¤ºä¾‹
    let three_d: [[[i32; 2]; 2]; 2] = [
        [[1, 2], [3, 4]],
        [[5, 6], [7, 8]],
    ];
    
    println!("ä¸‰ç»´æ•°ç»„å†…å®¹:");
    for (i, depth) in three_d.iter().enumerate() {
        for (j, row) in depth.iter().enumerate() {
            for (k, &value) in row.iter().enumerate() {
                print!("[{}][{}][{}] = {}  ", i, j, k, value);
            }
            println!();
        }
    }
}
```

**Result:**

```shell
çŸ©é˜µå†…å®¹:
matrix[0][0] = 1  matrix[0][1] = 2  matrix[0][2] = 3
matrix[1][0] = 4  matrix[1][1] = 5  matrix[1][2] = 6
matrix[1][2] = 6
ä¸‰ç»´æ•°ç»„å†…å®¹:
[0][0][0] = 1  [0][0][1] = 2
[0][1][0] = 3  [0][1][1] = 4
[1][0][0] = 5  [1][0][1] = 6
[1][1][0] = 7  [1][1][1] = 8
```

**å…³é”®ç‚¹ï¼š**

- ä½¿ç”¨`get`æ–¹æ³•å®‰å…¨åœ°è®¿é—®æ•°ç»„å…ƒç´ ï¼Œé¿å…è¶Šç•Œé”™è¯¯ã€‚
- ä½¿ç”¨`iter`æ–¹æ³•éå†æ•°ç»„ï¼Œå¹¶ä½¿ç”¨`enumerate`æ–¹æ³•è·å–ç´¢å¼•ã€‚
- ä½¿ç”¨`match`è¡¨è¾¾å¼æ£€æŸ¥`get`æ–¹æ³•è¿”å›çš„`Option`ç±»å‹ï¼Œä»¥å¤„ç†å¯èƒ½è¶Šç•Œçš„æƒ…å†µã€‚
- ä½¿ç”¨å¤šç»´æ•°ç»„æ—¶ï¼Œå¯ä»¥åµŒå¥—ä½¿ç”¨`iter`å’Œ`enumerate`æ–¹æ³•æ¥éå†æ¯ä¸ªç»´åº¦ã€‚
- ä½¿ç”¨`print!`å’Œ`println!`å®æ¥æ ¼å¼åŒ–è¾“å‡ºã€‚
- ...

#### æ•°ç»„è¶Šç•Œæ£€æŸ¥

```rust
fn array_bounds_checking() {
    let arr = [10, 20, 30];
    
    // å®‰å…¨çš„è®¿é—®
    if let Some(&value) = arr.get(1) {
        println!("arr[1] = {}", value);
    }
    
    // æ£€æŸ¥æ˜¯å¦è¶Šç•Œ
    match arr.get(5) {
        Some(value) => println!("arr[5] = {}", value),
        None => println!("æ•°ç»„è¶Šç•Œ! æœ€å¤§ç´¢å¼•: {}", arr.len() - 1),
    }
    
    // æ•°ç»„åˆ‡ç‰‡ï¼ˆå¼•ç”¨æ•°ç»„çš„ä¸€éƒ¨åˆ†ï¼‰
    let slice = &arr[0..2];  // åŒ…å«ç´¢å¼•0åˆ°1
    println!("åˆ‡ç‰‡å†…å®¹: {:?}", slice);
    
    let slice_to_end = &arr[1..];  // ä»ç´¢å¼•1åˆ°æœ«å°¾
    println!("ä»ç´¢å¼•1å¼€å§‹çš„åˆ‡ç‰‡: {:?}", slice_to_end);
    
    let slice_from_start = &arr[..2];  // ä»å¼€å¤´åˆ°ç´¢å¼•2ï¼ˆä¸åŒ…å«2ï¼‰
    println!("ä»å¼€å¤´åˆ°ç´¢å¼•2çš„åˆ‡ç‰‡: {:?}", slice_from_start);
    
    let full_slice = &arr[..];  // æ•´ä¸ªæ•°ç»„çš„åˆ‡ç‰‡
    println!("å®Œæ•´åˆ‡ç‰‡: {:?}", full_slice);
}
```

**Result:**

```shell
arr[1] = 20
æ•°ç»„è¶Šç•Œ! æœ€å¤§ç´¢å¼•: 2
åˆ‡ç‰‡å†…å®¹: [10, 20]
ä»ç´¢å¼•1å¼€å§‹çš„åˆ‡ç‰‡: [20, 30]
ä»å¼€å¤´åˆ°ç´¢å¼•2çš„åˆ‡ç‰‡: [10, 20]
å®Œæ•´åˆ‡ç‰‡: [10, 20, 30]
```

**å…³é”®ç‚¹ï¼š**

- ä½¿ç”¨`get`æ–¹æ³•å®‰å…¨åœ°è®¿é—®æ•°ç»„å…ƒç´ ï¼Œé¿å…è¶Šç•Œé”™è¯¯ã€‚
- ä½¿ç”¨`match`è¡¨è¾¾å¼æ£€æŸ¥`get`æ–¹æ³•è¿”å›çš„`Option`ç±»å‹ï¼Œä»¥å¤„ç†å¯èƒ½è¶Šç•Œçš„æƒ…å†µã€‚
- ä½¿ç”¨æ•°ç»„åˆ‡ç‰‡ï¼ˆå¼•ç”¨æ•°ç»„çš„ä¸€éƒ¨åˆ†ï¼‰æ¥è®¿é—®æ•°ç»„çš„ä¸€éƒ¨åˆ†ï¼Œé¿å…è¶Šç•Œé”™è¯¯ã€‚
- ...

#### å®ç”¨æ•°ç»„æ“ä½œ

```rust
fn array_operations() {
    let mut numbers = [64, 34, 25, 12, 22, 11, 90];
    
    println!("åŸå§‹æ•°ç»„: {:?}", numbers);
    
    // æŸ¥æ‰¾æœ€å¤§å€¼å’Œæœ€å°å€¼
    let max = numbers.iter().max().unwrap();
    let min = numbers.iter().min().unwrap();
    println!("æœ€å¤§å€¼: {}, æœ€å°å€¼: {}", max, min);
    
    // è®¡ç®—æ•°ç»„æ€»å’Œå’Œå¹³å‡å€¼
    let sum: i32 = numbers.iter().sum();
    let average = sum as f64 / numbers.len() as f64;
    println!("æ€»å’Œ: {}, å¹³å‡å€¼: {:.2}", sum, average);
    
    // è¿‡æ»¤å’Œå˜æ¢
    let even_numbers: Vec<_> = numbers.iter()
        .filter(|&&x| x % 2 == 0)
        .copied()
        .collect();
    println!("å¶æ•°: {:?}", even_numbers);
    
    let squared: Vec<_> = numbers.iter()
        .map(|&x| x * x)
        .collect();
    println!("å¹³æ–¹: {:?}", squared);
    
    // æ£€æŸ¥æ˜¯å¦åŒ…å«æŸä¸ªå€¼
    let contains_25 = numbers.contains(&25);
    let position = numbers.iter().position(|&x| x == 25);
    println!("åŒ…å«25: {}, ä½ç½®: {:?}", contains_25, position);
    
    // æ’åº
    let mut sorted = numbers;
    sorted.sort();
    println!("æ’åºå: {:?}", sorted);
}
```

**Resultï¼š**

```shell
åŸå§‹æ•°ç»„: [64, 34, 25, 12, 22, 11, 90]
æœ€å¤§å€¼: 90, æœ€å°å€¼: 11
æ€»å’Œ: 258, å¹³å‡å€¼: 36.86
å¶æ•°: [64, 34, 12, 22, 90]
å¹³æ–¹: [4096, 1156, 625, 144, 484, 121, 8100]
åŒ…å«25: true, ä½ç½®: Some(2)
æ’åºå: [11, 12, 22, 25, 34, 64, 90]
```

**å…³é”®ç‚¹ï¼š**

- `iter()` æ–¹æ³•è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œç”¨äºéå†æ•°ç»„å…ƒç´ ã€‚
- `sum()` æ–¹æ³•è®¡ç®—æ•°ç»„å…ƒç´ çš„æ€»å’Œã€‚
- `copied()` æ–¹æ³•å°†è¿­ä»£å™¨ä¸­çš„å…ƒç´ å¤åˆ¶åˆ°æ–°å‘é‡ä¸­ã€‚
- `filter()` æ–¹æ³•ç”¨äºè¿‡æ»¤æ•°ç»„å…ƒç´ ã€‚
- `map()` æ–¹æ³•ç”¨äºå˜æ¢æ•°ç»„å…ƒç´ ã€‚
- `contains()` æ–¹æ³•ç”¨äºæ£€æŸ¥æ•°ç»„æ˜¯å¦åŒ…å«æŸä¸ªå€¼ã€‚
- `position()` æ–¹æ³•ç”¨äºæŸ¥æ‰¾æ•°ç»„ä¸­æŸä¸ªå€¼çš„ç´¢å¼•ã€‚
- `sort()` æ–¹æ³•ç”¨äºå¯¹æ•°ç»„è¿›è¡Œæ’åºã€‚
- `enumerate()` æ–¹æ³•ç”¨äºåŒæ—¶è·å–æ•°ç»„å…ƒç´ çš„ç´¢å¼•å’Œå€¼ã€‚
- ...

#### å­—ç¬¦ä¸²æ•°ç»„å’Œå­—ç¬¦å¤„ç†

```rust
fn string_and_char_arrays() {
    // å­—ç¬¦ä¸²æ•°ç»„
    let fruits = ["è‹¹æœ", "é¦™è•‰", "æ©™å­", "è‘¡è„"];
    
    for (i, fruit) in fruits.iter().enumerate() {
        println!("fruits[{}] = {}", i, fruit);
    }
    
    // å­—ç¬¦æ•°ç»„
    let word = ['R', 'u', 's', 't'];
    let word_str: String = word.iter().collect();
    println!("å­—ç¬¦æ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸²: {}", word_str);
    
    // å­—ç¬¦æ•°ç»„çš„éå†
    for char in &word {
        println!("å­—ç¬¦: {}", char);
        // è½¬æ¢ä¸ºASCIIç 
        println!("ASCIIç : {}", *char as u8);
    }
    
    // è®¡ç®—å­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆä»¥å­—ç¬¦è®¡ï¼‰
    let multi_char_str = "ä½ å¥½ï¼Œä¸–ç•Œï¼ ğŸŒ";
    let chars: Vec<char> = multi_char_str.chars().collect();
    println!("å­—ç¬¦ä¸²: {}", multi_char_str);
    println!("å­—ç¬¦æ•°é‡: {}", chars.len());
    println!("å­—èŠ‚é•¿åº¦: {}", multi_char_str.len());
}
```

**Resultï¼š**

```shell
fruits[0] = è‹¹æœ
fruits[1] = é¦™è•‰
fruits[2] = æ©™å­
fruits[3] = è‘¡è„
å­—ç¬¦æ•°ç»„è½¬æ¢ä¸ºå­—ç¬¦ä¸²: Rust
å­—ç¬¦: R
ASCIIç : 82
å­—ç¬¦: u
ASCIIç : 117
å­—ç¬¦: s
ASCIIç : 115
å­—ç¬¦: t
ASCIIç : 116
å­—ç¬¦ä¸²: ä½ å¥½ï¼Œä¸–ç•Œï¼ ğŸŒ
å­—ç¬¦æ•°é‡: 8
å­—èŠ‚é•¿åº¦: 23
```

**å…³é”®ç‚¹ï¼š**

- `iter()` æ–¹æ³•ç”¨äºè·å–æ•°ç»„çš„è¿­ä»£å™¨ã€‚
- `enumerate()` æ–¹æ³•ç”¨äºåŒæ—¶è·å–æ•°ç»„å…ƒç´ çš„ç´¢å¼•å’Œå€¼ã€‚
- `collect()` æ–¹æ³•ç”¨äºå°†è¿­ä»£å™¨è½¬æ¢ä¸ºé›†åˆç±»å‹ã€‚
- `chars()` æ–¹æ³•ç”¨äºå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—ç¬¦è¿­ä»£å™¨ã€‚
- `len()` æ–¹æ³•ç”¨äºè·å–å­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆä»¥å­—ç¬¦è®¡ï¼‰ã€‚
- ...

#### å­—ç¬¦ä¸²åˆ‡ç‰‡

```rust

#### æ•°ç»„åœ¨å‡½æ•°ä¸­çš„åº”ç”¨

```rust
fn array_in_functions() {
    let arr = [1, 2, 3, 4, 5];
    
    // ä¼ é€’æ•°ç»„å¼•ç”¨
    let sum = sum_array(&arr);
    let max = max_array(&arr);
    
    println!("æ•°ç»„: {:?}", arr);
    println!("æ€»å’Œ: {}, æœ€å¤§å€¼: {}", sum, max);
    
    // ä¿®æ”¹æ•°ç»„ï¼ˆéœ€è¦mutï¼‰
    let mut mut_arr = [10, 20, 30];
    modify_array(&mut mut_arr);
    println!("ä¿®æ”¹å: {:?}", mut_arr);
    
    // è¿”å›æ•°ç»„
    let squared = square_array(&arr);
    println!("å¹³æ–¹å: {:?}", squared);
}

// è®¡ç®—æ•°ç»„æ€»å’Œ
fn sum_array(arr: &[i32]) -> i32 {
    arr.iter().sum()
}

// æ‰¾æœ€å¤§å€¼
fn max_array(arr: &[i32]) -> i32 {
    arr.iter().max().copied().unwrap_or(0)
}

// ä¿®æ”¹æ•°ç»„å…ƒç´ 
fn modify_array(arr: &mut [i32]) {
    for i in 0..arr.len() {
        arr[i] *= 2;
    }
}

// è¿”å›å¹³æ–¹æ•°ç»„
fn square_array(arr: &[i32]) -> Vec<i32> {
    arr.iter().map(|&x| x * x).collect()
}
```

**Resultï¼š**

```shell
æ•°ç»„: [1, 2, 3, 4, 5]
æ€»å’Œ: 15, æœ€å¤§å€¼: 5
ä¿®æ”¹å: [20, 40, 60]
å¹³æ–¹å: [1, 4, 9, 16, 25]
```

**å…³é”®ç‚¹ï¼š**

- `&arr` ä¼ é€’æ•°ç»„å¼•ç”¨ï¼Œé¿å…æ‰€æœ‰æƒè½¬ç§»ã€‚
- `&mut mut_arr` ä¼ é€’å¯å˜æ•°ç»„å¼•ç”¨ï¼Œå…è®¸ä¿®æ”¹æ•°ç»„ã€‚
- `&arr` è¿”å›æ•°ç»„å¼•ç”¨ï¼Œé¿å…æ‰€æœ‰æƒè½¬ç§»ã€‚
- `&arr` ä½œä¸ºå‚æ•°ä¼ é€’æ—¶ï¼Œä¸éœ€è¦æ˜¾å¼åœ°ä½¿ç”¨ `&`ï¼Œå› ä¸ºæ•°ç»„å¼•ç”¨å·²ç»æ˜¯å¼•ç”¨ç±»å‹ã€‚
- `&arr` è¿”å›æ•°ç»„å¼•ç”¨æ—¶ï¼Œä¸éœ€è¦æ˜¾å¼åœ°ä½¿ç”¨ `&`ï¼Œå› ä¸ºæ•°ç»„å¼•ç”¨å·²ç»æ˜¯å¼•ç”¨ç±»å‹ã€‚
- `&mut mut_arr` ä½œä¸ºå‚æ•°ä¼ é€’æ—¶ï¼Œéœ€è¦æ˜¾å¼åœ°ä½¿ç”¨ `&mut`ï¼Œå› ä¸ºæ•°ç»„å¼•ç”¨æ˜¯å¯å˜å¼•ç”¨ç±»å‹ã€‚
- `&mut mut_arr` è¿”å›æ•°ç»„å¼•ç”¨æ—¶ï¼Œéœ€è¦æ˜¾å¼åœ°ä½¿ç”¨ `&mut`ï¼Œå› ä¸ºæ•°ç»„å¼•ç”¨æ˜¯å¯å˜å¼•ç”¨ç±»å‹ã€‚
- `&arr` å’Œ `&mut mut_arr` åœ¨å‡½æ•°å†…éƒ¨éƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œä¸éœ€è¦æ˜¾å¼åœ°ä½¿ç”¨ `&` æˆ– `&mut`ã€‚
- ...

---

## 2.4 å­—ç¬¦ä¸²ç±»å‹

### 2.4.1 å­—ç¬¦ä¸²å­—é¢é‡å’Œåˆ‡ç‰‡

Rust ä¸­çš„å­—ç¬¦ä¸²å­—é¢é‡æ˜¯ä¸å¯å˜çš„ã€ç¡¬ç¼–ç çš„æ–‡æœ¬ï¼Œä½¿ç”¨åŒå¼•å·å®šä¹‰ï¼Œå¦‚ "hello"ã€‚å®ƒä»¬æ˜¯ `&str` ç±»å‹ï¼ˆå­—ç¬¦ä¸²åˆ‡ç‰‡ï¼‰ï¼ŒæŒ‡å‘é™æ€å†…å­˜ä¸­çš„ UTF-8 ç¼–ç å­—èŠ‚åºåˆ—ã€‚åˆ‡ç‰‡ï¼ˆsliceï¼‰æ˜¯å¼•ç”¨ç°æœ‰æ•°æ®çš„è§†å›¾ï¼Œå¦‚ `&[T]`ï¼Œå­—ç¬¦ä¸²åˆ‡ç‰‡ `&str `æ˜¯å¯¹å­—ç¬¦ä¸²çš„ä¸å¯å˜å¼•ç”¨ã€‚

```rust
fn string_slices() {
    // å­—ç¬¦ä¸²å­—é¢é‡ï¼ˆ&strï¼‰- ç¼–è¯‘æ—¶å¸¸é‡
    let greeting = "Hello, Rust!";
    let name = "World";
    
    // åˆ‡ç‰‡ï¼ˆä¸æ‹¥æœ‰æ‰€æœ‰æƒï¼‰
    let slice = &greeting[0..5];           // "Hello"
    let slice_from_middle = &greeting[7..11]; // "Rust"
    
    println!("å®Œæ•´é—®å€™: {}", greeting);
    println!("åˆ‡ç‰‡: {}", slice);
    
    // å­—ç¬¦ä¸²æ–¹æ³•
    let trimmed = "  hello  ".trim();      // "hello"
    let uppercase = "rust".to_uppercase(); // "RUST"
    let lowercase = "RUST".to_lowercase(); // "rust"
    
    // æŸ¥æ‰¾å’Œåˆ†å‰²
    let text = "one,two,three,four";
    let parts: Vec<&str> = text.split(',').collect();
    println!("åˆ†å‰²ç»“æœ: {:?}", parts);
    
    // æ›¿æ¢
    let replaced = "hello world".replace("world", "Rust");
    println!("æ›¿æ¢å: {}", replaced);
}
```

**Resultï¼š**

```shell
å®Œæ•´é—®å€™: Hello, Rust!
åˆ‡ç‰‡: Hello
åˆ†å‰²ç»“æœ: ["one", "two", "three", "four"]
æ›¿æ¢å: hello Rust
```

**å…³é”®ç‚¹ï¼š**

- å­—é¢é‡ç”Ÿå‘½å‘¨æœŸä¸º 'staticï¼Œä¸å¯å˜,å®ƒä»¬æ˜¯ `&str` ç±»å‹ã€‚
- åˆ‡ç‰‡ä¸æ‹¥æœ‰æ•°æ®ï¼Œä»…å€Ÿç”¨ï¼›ç´¢å¼•å¿…é¡»æ˜¯æœ‰æ•ˆ UTF-8 è¾¹ç•Œï¼Œå¦åˆ™ panicã€‚
- å¸¸ç”¨ä½œå‡½æ•°å‚æ•°ï¼Œä¿ƒè¿›é›¶æ‹·è´ã€‚
- å­—ç¬¦ä¸²åˆ‡ç‰‡æ˜¯å¼•ç”¨ç±»å‹ï¼Œå¯ä»¥å¼•ç”¨å­—ç¬¦ä¸²å­—é¢é‡æˆ– `String` ç±»å‹ã€‚
- å­—ç¬¦ä¸²åˆ‡ç‰‡å¯ä»¥ç”¨äºå­—ç¬¦ä¸²æ“ä½œï¼Œå¦‚æŸ¥æ‰¾ã€æ›¿æ¢å’Œåˆ†å‰²ç­‰ã€‚
- å­—ç¬¦ä¸²åˆ‡ç‰‡ä¸æ‹¥æœ‰æ‰€æœ‰æƒï¼Œå› æ­¤å®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä¸èƒ½è¶…è¿‡å®ƒä»¬å¼•ç”¨çš„æ•°æ®çš„ç”Ÿå‘½å‘¨æœŸã€‚
- å­—ç¬¦ä¸²åˆ‡ç‰‡å¯ä»¥ç”¨äºå­—ç¬¦ä¸²å­—é¢é‡å’Œ `String` ç±»å‹ï¼Œä½†ä¸èƒ½ç”¨äº `char` ç±»å‹ã€‚
- å­—ç¬¦ä¸²åˆ‡ç‰‡å¯ä»¥é€šè¿‡ `&str` ç±»å‹è½¬æ¢ä¸º `String` ç±»å‹ï¼Œä½†éœ€è¦ä½¿ç”¨ `to_string` æ–¹æ³•ã€‚
- å­—ç¬¦ä¸²åˆ‡ç‰‡å¯ä»¥é€šè¿‡ `split` æ–¹æ³•åˆ†å‰²ä¸ºå¤šä¸ªå­å­—ç¬¦ä¸²ï¼Œå¹¶è¿”å›ä¸€ä¸ª `Vec<&str>` ç±»å‹çš„ç»“æœã€‚
- ...

### 2.4.2 String ç±»å‹

String æ˜¯å¯å¢é•¿ã€å¯å˜ã€æ‹¥æœ‰çš„ UTF-8 ç¼–ç å­—ç¬¦ä¸²ï¼Œå­˜å‚¨åœ¨å †ä¸Šã€‚ä¸åŒäº `&str`ï¼ŒString æ‹¥æœ‰æ•°æ®ï¼Œå¯ä»¥ä¿®æ”¹ï¼ˆå¦‚è¿½åŠ ï¼‰ã€‚å®ƒå®ç°äº† Deref åˆ° &strï¼Œå…è®¸éšå¼è½¬æ¢ä¸ºåˆ‡ç‰‡ã€‚

```rust
fn string_type() {
    // String ç±»å‹ï¼ˆæ‹¥æœ‰æ‰€æœ‰æƒï¼‰
    let mut s = String::new();             // ç©ºå­—ç¬¦ä¸²
    let s1 = String::from("hello");        // ä»å­—ç¬¦ä¸²å­—é¢é‡åˆ›å»º
    let s2 = "world".to_string();          // è½¬æ¢ä¸º String
    
    // è¿½åŠ å†…å®¹
    s.push('A');                           // è¿½åŠ å­—ç¬¦
    s.push_str("pple");                    // è¿½åŠ å­—ç¬¦ä¸²
    s += " Banana";                        // è¿æ¥æ“ä½œç¬¦
    
    println!("å­—ç¬¦ä¸² s: {}", s);
    
    // æ ¼å¼åŒ–
    let name = "Alice";
    let age = 30;
    let formatted = format!("{} is {} years old", name, age);
    println!("æ ¼å¼åŒ–: {}", formatted);
    
    // ä½¿ç”¨å®
    println!("æµ‹è¯•å€¼: {}, å¦ä¸€ä¸ªå€¼: {}", 42, "text");
    
    // æ‰€æœ‰æƒç¤ºä¾‹
    let original = String::from("original");
    let moved = original;                  // æ‰€æœ‰æƒè½¬ç§»
    // println!("{}", original);           // ç¼–è¯‘é”™è¯¯ï¼original å·²ç§»åŠ¨
    println!("ç§»åŠ¨åçš„å­—ç¬¦ä¸²: {}", moved);
}
```

**Resultï¼š**

```shell
å­—ç¬¦ä¸² s: Apple Banana
æ ¼å¼åŒ–: Alice is 30 years old
æµ‹è¯•å€¼: 42, å¦ä¸€ä¸ªå€¼: text
ç§»åŠ¨åçš„å­—ç¬¦ä¸²: original
```

**å…³é”®ç‚¹ï¼š**

- `String` ç±»å‹æ˜¯æ‹¥æœ‰æ‰€æœ‰æƒçš„ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ `String::from` æˆ– `to_string` æ–¹æ³•æ¥åˆ›å»º `String` å®ä¾‹ã€‚
- `push` å’Œ `push_str` æ–¹æ³•ç”¨äºå‘ `String` å®ä¾‹ä¸­è¿½åŠ å†…å®¹ã€‚
- æ‰€æœ‰æƒè§„åˆ™é€‚ç”¨ï¼šç§»åŠ¨åä¸å¯ç”¨ï¼Œé™¤éå…‹éš†ï¼ˆ.clone()ï¼‰ã€‚
- `format!` å®ç”¨äºæ ¼å¼åŒ–å­—ç¬¦ä¸²ã€‚
- `println!` å®ç”¨äºæ‰“å°å­—ç¬¦ä¸²ã€‚
- `String` çš„æ‰€æœ‰æƒè½¬ç§»ç¤ºä¾‹å±•ç¤ºäº†æ‰€æœ‰æƒè½¬ç§»çš„æ¦‚å¿µï¼Œå³ `original` åœ¨èµ‹å€¼ç»™ `moved` åï¼Œ`original` ä¸å†æœ‰æ•ˆã€‚
- ...

---

## 2.5 æ§åˆ¶æµ

### 2.5.1 if æ¡ä»¶è¯­å¥

Rust çš„ `if` æ˜¯è¡¨è¾¾å¼ï¼Œå¯è¿”å›å€¼çš„æ¡ä»¶åˆ†æ”¯ã€‚æ— éœ€æ‹¬å·åŒ…å›´æ¡ä»¶ï¼Œæ”¯æŒ `else` å’Œ `else if`ã€‚æ¡ä»¶å¿…é¡»æ˜¯ bool ç±»å‹ï¼Œæ— éšå¼è½¬æ¢ã€‚

```rust
fn conditional_statements() {
    let number = 7;
    
    // åŸºæœ¬ if-else
    if number < 5 {
        println!("æ•°å­—å°äº 5");
    } else if number == 5 {
        println!("æ•°å­—ç­‰äº 5");
    } else {
        println!("æ•°å­—å¤§äº 5");
    }
    
    // if ä½œä¸ºè¡¨è¾¾å¼ï¼ˆè¿”å›å€¼ï¼‰
    let grade = if number >= 90 {
        "A"
    } else if number >= 80 {
        "B"
    } else if number >= 70 {
        "C"
    } else {
        "F"
    };
    
    println!("æˆç»©: {}", grade);
    
    // æ¡ä»¶èµ‹å€¼
    let status = if number % 2 == 0 {
        "å¶æ•°"
    } else {
        "å¥‡æ•°"
    };
    println!("{} æ˜¯ {}", number, status);
}
```

**Resultï¼š**

```shell
æ•°å­—å¤§äº 5
æˆç»©: F
7 æ˜¯ å¥‡æ•°
```

**å…³é”®ç‚¹ï¼š**

- `if` è¯­å¥çš„åŸºæœ¬ç”¨æ³•ï¼ŒåŒ…æ‹¬æ¡ä»¶åˆ¤æ–­å’Œåˆ†æ”¯æ‰§è¡Œã€‚
- `if` è¯­å¥å¯ä»¥ä½œä¸ºè¡¨è¾¾å¼è¿”å›å€¼ã€‚
- `if` è¯­å¥çš„åµŒå¥—ä½¿ç”¨ã€‚
- æ¡ä»¶èµ‹å€¼çš„ä½¿ç”¨ï¼Œæ ¹æ®æ¡ä»¶ä¸ºå˜é‡èµ‹å€¼ã€‚
- `if` è¯­å¥çš„æ‰§è¡Œé¡ºåºï¼Œæ ¹æ®æ¡ä»¶åˆ¤æ–­ç»“æœé€‰æ‹©æ‰§è¡Œç›¸åº”çš„åˆ†æ”¯ã€‚
- `if` è¯­å¥çš„è¿”å›å€¼ï¼Œå¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œä½†éœ€è¦ä¸ä¸Šä¸‹æ–‡ä¸­çš„å˜é‡ç±»å‹åŒ¹é…ã€‚
- ...

---

### 2.5.2 å¾ªç¯æ§åˆ¶

#### loop æ— ç©·å¾ªç¯

```rust

### 2.5.2 å¾ªç¯æ§åˆ¶

#### loop æ— ç©·å¾ªç¯

`loop` æ˜¯æ— é™å¾ªç¯ï¼Œç›´åˆ°æ˜¾å¼ `break`ã€‚å¯è¿”å›å€¼çš„è¡¨è¾¾å¼ï¼Œæ”¯æŒæ ‡ç­¾ç”¨äºåµŒå¥—å¾ªç¯æ§åˆ¶ã€‚

```rust
fn loop_examples() {
    // åŸºæœ¬ loop
    let mut counter = 0;
    loop {
        counter += 1;
        println!("è®¡æ•°å™¨: {}", counter);
        
        if counter >= 5 {
            break;                          // é€€å‡ºå¾ªç¯
        }
    }
    
    // loop ä½œä¸ºè¡¨è¾¾å¼ï¼ˆè¿”å›å€¼ï¼‰
    let result = loop {
        counter += 1;
        
        if counter == 10 {
            break counter;                 // é€€å‡ºå¹¶è¿”å›å€¼
        }
    };
    
    println!("å¾ªç¯ç»“æœ: {}", result);
}
```

**Resultï¼š**

```shell
è®¡æ•°å™¨: 1
è®¡æ•°å™¨: 2
è®¡æ•°å™¨: 3
è®¡æ•°å™¨: 4
è®¡æ•°å™¨: 5
å¾ªç¯ç»“æœ: 10
```

**å…³é”®ç‚¹ï¼š**

- `break` é€€å‡ºå¾ªç¯
- `break` å¯ä»¥è¿”å›å€¼
- `continue` è·³è¿‡æœ¬æ¬¡å¾ªç¯
- `loop` å¯ä»¥ä½œä¸ºè¡¨è¾¾å¼ï¼Œè¿”å›å€¼
- `loop` å¯ä»¥åµŒå¥—
- `loop` å¯ä»¥ä¸æ ‡ç­¾ï¼ˆlabelï¼‰é…åˆä½¿ç”¨ï¼Œç”¨äºé€€å‡ºå¤šå±‚åµŒå¥—å¾ªç¯,æ ‡ç­¾å¦‚ 'outer: loop {} ç”¨äºå¤šå±‚æ§åˆ¶ã€‚
- ...

#### while æ¡ä»¶å¾ªç¯

`while` æ˜¯æ¡ä»¶å¾ªç¯ï¼Œåœ¨æ¡ä»¶ä¸º `true` æ—¶æ‰§è¡Œã€‚æ¡ä»¶å¿…é¡»æ˜¯ boolã€‚

```rust
fn while_examples() {
    let mut number = 3;
    
    while number != 0 {
        println!("å€’è®¡æ—¶: {}", number);
        number -= 1;
    }
    
    println!("å‘å°„ï¼");
    
    // æ•°ç»„éå†
    let array = [10, 20, 30, 40, 50];
    let mut index = 0;
    
    while index < array.len() {
        println!("ç´¢å¼• {}: å€¼ {}", index, array[index]);
        index += 1;
    }
}
```

**Resultï¼š**

```shell
å€’è®¡æ—¶: 3
å€’è®¡æ—¶: 2
å€’è®¡æ—¶: 1
å‘å°„ï¼
ç´¢å¼• 0: å€¼ 10
ç´¢å¼• 1: å€¼ 20
ç´¢å¼• 2: å€¼ 30
ç´¢å¼• 3: å€¼ 40
ç´¢å¼• 4: å€¼ 50
```

**Resultï¼š**

- æ—  do-whileï¼Œä½†å¯ç”¨ loop æ¨¡æ‹Ÿã€‚
- é€‚åˆæœªçŸ¥è¿­ä»£æ¬¡æ•°ä½†æœ‰æ¡ä»¶çš„æƒ…å†µã€‚
- `while` å¾ªç¯å¯ä»¥éå†æ•°ç»„ï¼Œå¾ªç¯ä¹Ÿå¯ä»¥åµŒå¥—
- `while` å¾ªç¯å¯ä»¥ä¸æ ‡ç­¾ï¼ˆlabelï¼‰é…åˆä½¿ç”¨ï¼Œç”¨äºé€€å‡ºå¤šå±‚åµŒå¥—å¾ªç¯
- `while` å¾ªç¯å¯ä»¥ä¸ `break` å’Œ `continue` é…åˆä½¿ç”¨ï¼Œç”¨äºæ§åˆ¶å¾ªç¯çš„æ‰§è¡Œ
- `while` å¾ªç¯å¯ä»¥ä¸ `loop` é…åˆä½¿ç”¨ï¼Œç”¨äºåˆ›å»ºæ— é™å¾ªç¯
- `while` å¾ªç¯å¯ä»¥ä¸ `for` å¾ªç¯é…åˆä½¿ç”¨ï¼Œç”¨äºéå†é›†åˆ
- `while` å¾ªç¯å¯ä»¥ä¸ `match` é…åˆä½¿ç”¨ï¼Œç”¨äºå¤„ç†å¤šç§æƒ…å†µ
- `while` å¾ªç¯å¯ä»¥ä¸ `if` é…åˆä½¿ç”¨ï¼Œç”¨äºæ¡ä»¶åˆ¤æ–­
- `while` å¾ªç¯å¯ä»¥ä¸ `let` é…åˆä½¿ç”¨ï¼Œç”¨äºå£°æ˜å˜é‡
- `while` å¾ªç¯å¯ä»¥ä¸ `return` é…åˆä½¿ç”¨ï¼Œç”¨äºè¿”å›å€¼
- `while` å¾ªç¯å¯ä»¥ä¸ `yield` é…åˆä½¿ç”¨ï¼Œç”¨äºç”Ÿæˆå™¨å‡½æ•°
- `while` å¾ªç¯å¯ä»¥ä¸ `try` é…åˆä½¿ç”¨ï¼Œç”¨äºå¤„ç†é”™è¯¯
- `while` å¾ªç¯å¯ä»¥ä¸ `await` é…åˆä½¿ç”¨ï¼Œç”¨äºå¼‚æ­¥ç¼–ç¨‹
- `while` å¾ªç¯å¯ä»¥ä¸ `panic!` é…åˆä½¿ç”¨ï¼Œç”¨äºå¤„ç†å¼‚å¸¸
- `while` å¾ªç¯å¯ä»¥ä¸ `println!` é…åˆä½¿ç”¨ï¼Œç”¨äºè¾“å‡ºæ—¥å¿—
- `while` å¾ªç¯å¯ä»¥ä¸ `debug!`ã€`info!`ç­‰é…åˆä½¿ç”¨ï¼Œç”¨äºè°ƒè¯•
- `while` å¾ªç¯å¯ä»¥ä¸ `assert!` é…åˆä½¿ç”¨ï¼Œç”¨äºæ–­è¨€
- `while` å¾ªç¯å¯ä»¥ä¸ `unwrap!`ã€ `expect!` é…åˆä½¿ç”¨ï¼Œç”¨äºå¤„ç† `Option` å’Œ `Result`ç­‰ç­‰
- ...

#### for å¾ªç¯å’Œè¿­ä»£å™¨

`for` ç”¨äºè¿­ä»£é›†åˆï¼Œå¦‚èŒƒå›´æˆ–è¿­ä»£å™¨ã€‚è¯­æ³• `for item in iterator {}`ï¼Œé«˜æ•ˆå¤„ç†æ‰€æœ‰æƒã€‚

```rust
fn for_loop_examples() {
    // åŸºæœ¬ for å¾ªç¯
    for i in 0..5 {                        // 0 åˆ° 4
        println!("for å¾ªç¯: {}", i);
    }
    
    // åŒ…å«ç»“æŸå€¼çš„ range
    for i in 0..=5 {                       // 0 åˆ° 5
        println!("åŒ…å«ç»“æŸå€¼: {}", i);
    }
    
    // æ•°ç»„è¿­ä»£
    let array = [1, 2, 3, 4, 5];
    for item in array {
        println!("æ•°ç»„é¡¹: {}", item);
    }
    
    // ç´¢å¼•å’Œå€¼çš„è¿­ä»£
    let names = vec!["Alice", "Bob", "Charlie"];
    for (index, name) in names.iter().enumerate() {
        println!("{}: {}", index, name);
    }
    
    // å­—ç¬¦ä¸²å­—ç¬¦è¿­ä»£
    let text = "Rust";
    for char in text.chars() {
        println!("å­—ç¬¦: {}", char);
    }
    
    // å­—èŠ‚è¿­ä»£
    for byte in text.bytes() {
        println!("å­—èŠ‚: {}", byte);
    }
}
```

**Resultï¼š**

```shell
for å¾ªç¯: 0
for å¾ªç¯: 1
for å¾ªç¯: 2
for å¾ªç¯: 3
for å¾ªç¯: 4
åŒ…å«ç»“æŸå€¼: 0
åŒ…å«ç»“æŸå€¼: 1
åŒ…å«ç»“æŸå€¼: 2
åŒ…å«ç»“æŸå€¼: 3
åŒ…å«ç»“æŸå€¼: 4
åŒ…å«ç»“æŸå€¼: 5
æ•°ç»„é¡¹: 1
æ•°ç»„é¡¹: 2
æ•°ç»„é¡¹: 3
æ•°ç»„é¡¹: 4
æ•°ç»„é¡¹: 5
0: Alice
1: Bob
2: Charlie
å­—ç¬¦: R
å­—ç¬¦: u
å­—ç¬¦: s
å­—ç¬¦: t
å­—èŠ‚: 82
å­—èŠ‚: 117
å­—èŠ‚: 115
å­—èŠ‚: 116
```

**å…³é”®ç‚¹ï¼š**

- `for` å¾ªç¯ç”¨äºéå†èŒƒå›´ã€æ•°ç»„ã€å‘é‡ã€å­—ç¬¦ä¸²ç­‰ã€‚
- `0..5` åˆ›å»ºä¸€ä¸ªä» 0 åˆ° 4 çš„èŒƒå›´ã€‚
- `0..=5` åˆ›å»ºä¸€ä¸ªä» 0 åˆ° 5 çš„èŒƒå›´ï¼ˆåŒ…å« 5ï¼‰ã€‚
- `array` æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œ`names` æ˜¯ä¸€ä¸ªå‘é‡ã€‚
- `enumerate` æ–¹æ³•ç”¨äºè·å–ç´¢å¼•å’Œå€¼ã€‚
- ...

### 2.5.3 æ¨¡å¼åŒ¹é…

æ¨¡å¼åŒ¹é…é€šè¿‡ `match` è¡¨è¾¾å¼è§£æ„å€¼ï¼Œå¤„ç†å¤šç§æƒ…å†µã€‚å¿…é¡»ç©·å°½æ‰€æœ‰å¯èƒ½ï¼ˆæˆ–ç”¨ _ é€šé…ï¼‰ã€‚æ”¯æŒç»‘å®šã€å®ˆå«å’ŒåµŒå¥—ã€‚

```rust
fn pattern_matching() {
    let x = 42;
    
    match x {
        0 => println!("é›¶"),
        1..=10 => println!("ä¸€åˆ°åä¹‹é—´"),
        20 | 30 | 40 => println!("20, 30 æˆ– 40"),
        n if n % 2 == 0 => println!("å¶æ•°: {}", n),
        _ => println!("å…¶ä»–å€¼: {}", x),    // é€šé…ç¬¦
    }
    
    // ç»‘å®šå€¼çš„æ¨¡å¼
    match x {
        0 => println!("é›¶"),
        1 => println!("ä¸€"),
        n => println!("å…¶ä»–: {}", n),      // ç»‘å®šå€¼
    }
    
    // å¤åˆæ¨¡å¼
    let point = (0, 7);
    match point {
        (0, 0) => println!("åŸç‚¹"),
        (0, y) => println!("åœ¨ Y è½´ä¸Š: y = {}", y),
        (x, 0) => println!("åœ¨ X è½´ä¸Š: x = {}", x),
        (x, y) => println!("ç‚¹ ({}, {})", x, y),
    }
}
```

**Resultï¼š**

```shell
å¶æ•°: 42
å…¶ä»–: 42
åœ¨ Y è½´ä¸Š: y = 7
```

**å…³é”®ç‚¹ï¼š**

- æ¨¡å¼å¦‚ç»‘å®šï¼ˆx @ 1..=5ï¼‰ã€è§£æ„ï¼ˆå…ƒç»„ã€ç»“æ„ä½“ï¼‰ã€‚
- ä¸ if letã€while let ç»“åˆç®€åŒ–å¯é€‰åŒ¹é…ã€‚
- `match` è¯­å¥ç”¨äºæ¨¡å¼åŒ¹é…ã€‚
- `if` è¡¨è¾¾å¼å¯ä»¥åœ¨ `match` åˆ†æ”¯ä¸­ä½¿ç”¨ã€‚
- `_` æ˜¯é€šé…ç¬¦ï¼ŒåŒ¹é…ä»»ä½•å€¼ã€‚
- ç»‘å®šå€¼å¯ä»¥åœ¨ `match` åˆ†æ”¯ä¸­ä½¿ç”¨ã€‚
- å¤åˆæ¨¡å¼å¯ä»¥åŒ¹é…å¤šä¸ªå€¼ã€‚
- `match` è¯­å¥å¿…é¡»è¦†ç›–æ‰€æœ‰å¯èƒ½çš„å€¼ã€‚
- `match` è¯­å¥å¯ä»¥è¿”å›å€¼ã€‚
- `match` è¯­å¥ç”¨é€”å¹¿æ³›,å¯ç”¨äºé”™è¯¯å¤„ç†ã€æšä¸¾ç±»å‹ã€å…ƒç»„ã€ç»“æ„ä½“ã€å¼•ç”¨(å¯å˜/ä¸å¯å˜)ã€åˆ‡ç‰‡ã€æ•°ç»„ã€å­—ç¬¦ä¸²ã€é—­åŒ…ã€å‡½æ•°ã€å®ã€æ¨¡å¼åŒ¹é…ã€ç±»å‹è½¬æ¢ã€ç±»å‹æ£€æŸ¥ç­‰åœºæ™¯ã€‚
- ...

---

## 2.6 å‡½æ•°å®šä¹‰ä¸è°ƒç”¨

### 2.6.1 å‡½æ•°åŸºç¡€

Rust ä¸­çš„å‡½æ•°æ˜¯ä»£ç çš„å¯é‡ç”¨å—ï¼Œé€šè¿‡ `fn` å…³é”®å­—å®šä¹‰ã€‚å‡½æ•°åä½¿ç”¨è›‡å½¢å‘½åæ³•ï¼ˆsnake_caseï¼‰ï¼Œå¹¶å¯æ¥å—å‚æ•°å’Œè¿”å›å€¼ã€‚æ¯ä¸ªç¨‹åºè‡³å°‘æœ‰ä¸€ä¸ª `main` å‡½æ•°ä½œä¸ºå…¥å£ã€‚å‡½æ•°ä½“ç”¨ `{}`åŒ…å›´ï¼Œæ”¯æŒè¡¨è¾¾å¼å’Œè¯­å¥ã€‚Rust å‡½æ•°æ˜¯é™æ€ç±»å‹çš„ï¼Œç¡®ä¿ç±»å‹å®‰å…¨ã€‚

```rust
// å‡½æ•°å®šä¹‰
fn greet(name: &str) {
    println!("ä½ å¥½, {}!", name);
}

// æœ‰è¿”å›å€¼çš„å‡½æ•°
fn add(a: i32, b: i32) -> i32 {
    a + b                                 // æ²¡æœ‰åˆ†å·è¡¨ç¤ºè¿”å›å€¼
}

// æ˜¾å¼è¿”å›è¯­å¥
fn multiply(x: i32, y: i32) -> i32 {
    return x * y;                         // æ˜¾å¼è¿”å›
}

// å‡½æ•°è°ƒç”¨
fn function_examples() {
    greet("Rust");
    let sum = add(5, 3);
    let product = multiply(4, 7);
    
    println!("5 + 3 = {}", sum);
    println!("4 Ã— 7 = {}", product);
    
    // å‡½æ•°ä½œä¸ºè¡¨è¾¾å¼
    let result = {
        let a = 10;
        let b = 20;
        a + b                             // å—è¡¨è¾¾å¼è¿”å›å€¼
    };
    println!("å—è¡¨è¾¾å¼ç»“æœ: {}", result);
}
```

**Resultï¼š**

```shell
ä½ å¥½, Rust!
5 + 3 = 8
4 Ã— 7 = 28
å—è¡¨è¾¾å¼ç»“æœ: 30
```

**å…³é”®ç‚¹ï¼š**

- å‡½æ•°å®šä¹‰ä½¿ç”¨ `fn` å…³é”®å­—ã€‚
- å‡½æ•°å‚æ•°ç±»å‹åœ¨å‚æ•°ååé¢æŒ‡å®šã€‚
- å‡½æ•°è¿”å›å€¼ç±»å‹åœ¨ `->` åé¢æŒ‡å®šã€‚
- å‡½æ•°ä½“ä¸­çš„æœ€åä¸€è¡Œè¡¨è¾¾å¼æ˜¯è¿”å›å€¼ï¼Œä¸éœ€è¦åˆ†å·ã€‚
- å‡½æ•°è°ƒç”¨ä½¿ç”¨å‡½æ•°åå’Œå‚æ•°åˆ—è¡¨ã€‚
- å‡½æ•°å¯ä»¥è¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥ä¸è¿”å›å€¼ã€‚
- å‡½æ•°å¯ä»¥åŒ…å«å—è¡¨è¾¾å¼ï¼Œå—è¡¨è¾¾å¼çš„æœ€åä¸€è¡Œæ˜¯è¿”å›å€¼ã€‚
- å‡½æ•°å¯ä»¥åµŒå¥—å®šä¹‰ï¼Œä½†ä¸èƒ½åµŒå¥—è°ƒç”¨ã€‚
- å‡½æ•°å¯ä»¥é€’å½’è°ƒç”¨ï¼Œä½†ä¸èƒ½é€’å½’å®šä¹‰ã€‚
- å‡½æ•°å¯ä»¥æ¥å—å¯å˜å‚æ•°ï¼Œä½†ä¸èƒ½æ¥å—å¯å˜å‚æ•°æ•°é‡ã€‚
- ...

### 2.6.2 å‡½æ•°å‚æ•°å’Œè¿”å›å€¼

å‡½æ•°å‚æ•°åœ¨æ‹¬å·ä¸­å®šä¹‰ï¼ŒæŒ‡å®šç±»å‹ã€‚Rust ä½¿ç”¨æ‰€æœ‰æƒç³»ç»Ÿï¼šå‚æ•°å¯é€šè¿‡å€¼ä¼ é€’ï¼ˆç§»åŠ¨æ‰€æœ‰æƒï¼‰æˆ–å¼•ç”¨ï¼ˆå€Ÿç”¨ï¼‰ã€‚å¯å˜å‚æ•°éœ€ç”¨ `mut`ã€‚å‚æ•°æ˜¯ä¸å¯å˜çš„ï¼Œé™¤éæ˜¾å¼æ ‡è®°ã€‚
å‡½æ•°é€šè¿‡ `-> Type` æŒ‡å®šè¿”å›å€¼ç±»å‹ã€‚æœ€åè¡¨è¾¾å¼éšå¼è¿”å›ï¼Œæˆ–ç”¨ `return` æ˜¾å¼è¿”å›ã€‚æ— è¿”å›å€¼é»˜è®¤ä¸º `()`ï¼ˆå•å…ƒç±»å‹ï¼‰ã€‚å¤šå€¼è¿”å›ç”¨å…ƒç»„ã€‚

```rust
// å¤šä¸ªå‚æ•°
fn calculate_area(length: f64, width: f64) -> f64 {
    length * width
}

// å¯å˜å‚æ•°æ•°é‡
fn print_values(values: &[i32]) {
    for value in values {
        println!("å€¼: {}", value);
    }
}

// å…ƒç»„è¿”å›
fn get_coordinates() -> (i32, i32) {
    (10, 20)
}

// å‘½åè¿”å›ç»“æ„
#[derive(Debug)]
struct Rectangle {
    width: f64,
    height: f64,
}

fn create_rectangle(width: f64, height: f64) -> Rectangle {
    Rectangle { width, height }
}

fn calculate_rectangle_area(rect: &Rectangle) -> f64 {
    rect.width * rect.height
}

fn function_parameters() {
    let area = calculate_area(5.0, 3.0);
    println!("çŸ©å½¢é¢ç§¯: {}", area);
    
    let values = vec![1, 2, 3, 4, 5];
    print_values(&values);
    
    let (x, y) = get_coordinates();
    println!("åæ ‡: ({}, {})", x, y);
    
    let rectangle = create_rectangle(4.0, 6.0);
    let rect_area = calculate_rectangle_area(&rectangle);
    println!("çŸ©å½¢é¢ç§¯: {}", rect_area);
}
```

**Resultï¼š**

```shell
çŸ©å½¢é¢ç§¯: 15
å€¼: 1
å€¼: 2
å€¼: 3
å€¼: 4
å€¼: 5
åæ ‡: (10, 20)
çŸ©å½¢é¢ç§¯: 24
```

**å…³é”®ç‚¹ï¼š**

- **Rust** ä¸­çš„å‡½æ•°å‚æ•°å’Œè¿”å›å€¼ç±»å‹å¿…é¡»æ˜¾å¼å£°æ˜ã€‚
- **Rust** ä¸­çš„å‡½æ•°å‚æ•°å’Œè¿”å›å€¼ç±»å‹å¯ä»¥æ˜¯æ³›å‹ã€å…ƒç»„ã€ç»“æ„ä½“ã€æšä¸¾ã€é—­åŒ…ç­‰å¤šç§ç±»å‹ã€‚
- ...

### 2.6.3 é«˜é˜¶å‡½æ•°ç¤ºä¾‹

```rust
// åŸºç¡€å‡½æ•°
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

// å‡½æ•°ä½œä¸ºå‚æ•°
fn apply_function<F>(value: i32, f: F) -> i32
where
    F: Fn(i32) -> i32,
{
    f(value)
}

// å‡½æ•°ä½œä¸ºè¿”å›å€¼
fn get_operation(operation: &str) -> fn(i32, i32) -> i32 {
    match operation {
        "add" => add,
        "multiply" => multiply,
        _ => add, // é»˜è®¤æ“ä½œ
    }
}

fn higher_order_functions() {
    let result1 = apply_function(5, |x| x * x); // é—­åŒ…
    let result2 = apply_function(10, |x| x + 100); // å¦ä¸€ä¸ªé—­åŒ…

    println!("å¹³æ–¹: {}", result1);
    println!("åŠ 100: {}", result2);

    let operation = get_operation("add");
    let result3 = operation(15, 25);
    println!("å‡½æ•°æŒ‡é’ˆç»“æœ: {}", result3);
}
```

**Resultï¼š**

```shell
å¹³æ–¹: 25
åŠ 100: 110
å‡½æ•°æŒ‡é’ˆç»“æœ: 40
```

**å…³é”®ç‚¹ï¼š**

- **Rust** ä¸­çš„å‡½æ•°å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’ã€‚
- **Rust** ä¸­çš„å‡½æ•°å¯ä»¥ä½œä¸ºè¿”å›å€¼ã€‚
- **Rust** ä¸­çš„é—­åŒ…æ˜¯ä¸€ç§åŒ¿åå‡½æ•°ï¼Œå¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’æˆ–ä½œä¸ºè¿”å›å€¼ã€‚
- **Rust** ä¸­çš„å‡½æ•°æŒ‡é’ˆæ˜¯ä¸€ç§æŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆï¼Œå¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’æˆ–ä½œä¸ºè¿”å›å€¼ã€‚
- **Rust** ä¸­çš„æ³›å‹å‡½æ•°å¯ä»¥æ¥å—ä¸åŒç±»å‹çš„å‚æ•°ï¼Œå¹¶è¿”å›ä¸åŒç±»å‹çš„å€¼ã€‚
- **Rust** ä¸­çš„å‡½æ•°å¯ä»¥æ¥å—å…ƒç»„ã€ç»“æ„ä½“ã€æšä¸¾ç­‰å¤šç§ç±»å‹çš„å‚æ•°ï¼Œå¹¶è¿”å›ä¸åŒç±»å‹çš„å€¼ã€‚
- **Rust** ä¸­çš„å‡½æ•°å¯ä»¥æ¥å—å¯å˜å‚æ•°ï¼Œå¹¶è¿”å›ä¸åŒç±»å‹çš„å€¼ã€‚
- ...

---

## 2.7 å®è·µé¡¹ç›®ï¼šç§‘å­¦è®¡ç®—å™¨ä¸æ•°æ®å¤„ç†å·¥å…·

### 2.7.1 é¡¹ç›®éœ€æ±‚åˆ†æ

åˆ›å»ºä¸€ä¸ªåŠŸèƒ½å®Œå–„çš„ç§‘å­¦è®¡ç®—å™¨ï¼Œæ”¯æŒï¼š

- åŸºç¡€å’Œç§‘å­¦è¿ç®—
- è¡¨è¾¾å¼è§£æå’Œæ±‚å€¼
- æ•°æ®ç»Ÿè®¡åˆ†æ
- å†å²è®°å½•åŠŸèƒ½

### 2.7.2 é¡¹ç›®ç»“æ„è®¾è®¡

```rust
// src/main.rs
mod calculator;
mod data;
mod history;
mod utils;

use calculator::{Calculator, Operation};
use data::Statistics;
use history::HistoryManager;
use utils::Error;

fn main() -> Result<(), Error> {
    println!("=== ç§‘å­¦è®¡ç®—å™¨ v1.0 ===");
    
    let mut calculator = Calculator::new();
    let mut history = HistoryManager::new();
    
    // ç¤ºä¾‹è®¡ç®—
    run_example_calculations(&mut calculator, &mut history)?;
    
    Ok(())
}

fn run_example_calculations(
    calc: &mut Calculator, 
    history: &mut HistoryManager
) -> Result<(), Error> {
    // åŸºç¡€è¿ç®—
    let result1 = calc.add(10.0, 5.0)?;
    println!("10 + 5 = {}", result1);
    history.add_record("10 + 5", result1);
    
    let result2 = calc.multiply(result1, 2.0)?;
    println!("({}) Ã— 2 = {}", result1, result2);
    history.add_record("10 + 5 * 2", result2);
    
    // ç§‘å­¦è¿ç®—
    let result3 = calc.sqrt(16.0)?;
    println!("âˆš16 = {}", result3);
    history.add_record("âˆš16", result3);
    
    let result4 = calc.sin(30.0_f64.to_radians())?;
    println!("sin(30Â°) = {}", result4);
    history.add_record("sin(30Â°)", result4);
    
    // è¡¨è¾¾å¼æ±‚å€¼
    let expr_result = calc.evaluate_expression("(10 + 5) * 2 - âˆš16")?;
    println!("(10 + 5) * 2 - âˆš16 = {}", expr_result);
    history.add_record("(10 + 5) * 2 - âˆš16", expr_result);
    
    // ç»Ÿè®¡è®¡ç®—
    let data = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];
    let stats = calc.calculate_statistics(&data)?;
    println!("æ•°æ®é›†ç»Ÿè®¡: {:?}", stats);
    
    history.display();
    
    Ok(())
}
```

### 2.7.3 è®¡ç®—å™¨æ ¸å¿ƒæ¨¡å—

```rust
// src/calculator/mod.rs
pub mod operations;
pub mod parser;
pub mod evaluator;

use operations::Operation;
use parser::ExpressionParser;
use evaluator::ExpressionEvaluator;
use utils::Error;

pub struct Calculator {
    parser: ExpressionParser,
    evaluator: ExpressionEvaluator,
}

impl Calculator {
    pub fn new() -> Self {
        Self {
            parser: ExpressionParser::new(),
            evaluator: ExpressionEvaluator::new(),
        }
    }
    
    // åŸºç¡€è¿ç®—æ–¹æ³•
    pub fn add(&self, a: f64, b: f64) -> Result<f64, Error> {
        Ok(a + b)
    }
    
    pub fn subtract(&self, a: f64, b: f64) -> Result<f64, Error> {
        Ok(a - b)
    }
    
    pub fn multiply(&self, a: f64, b: f64) -> Result<f64, Error> {
        Ok(a * b)
    }
    
    pub fn divide(&self, a: f64, b: f64) -> Result<f64, Error> {
        if b == 0.0 {
            return Err(Error::DivisionByZero);
        }
        Ok(a / b)
    }
    
    pub fn power(&self, base: f64, exponent: f64) -> Result<f64, Error> {
        Ok(base.powf(exponent))
    }
    
    pub fn sqrt(&self, value: f64) -> Result<f64, Error> {
        if value < 0.0 {
            return Err(Error::NegativeSquareRoot);
        }
        Ok(value.sqrt())
    }
    
    pub fn sin(&self, angle: f64) -> Result<f64, Error> {
        Ok(angle.sin())
    }
    
    pub fn cos(&self, angle: f64) -> Result<f64, Error> {
        Ok(angle.cos())
    }
    
    pub fn tan(&self, angle: f64) -> Result<f64, Error> {
        Ok(angle.tan())
    }
    
    pub fn ln(&self, value: f64) -> Result<f64, Error> {
        if value <= 0.0 {
            return Err(Error::InvalidLogarithm);
        }
        Ok(value.ln())
    }
    
    pub fn log(&self, value: f64, base: f64) -> Result<f64, Error> {
        if value <= 0.0 || base <= 0.0 || base == 1.0 {
            return Err(Error::InvalidLogarithm);
        }
        Ok(value.log(base))
    }
    
    pub fn factorial(&self, n: u64) -> Result<f64, Error> {
        if n > 20 {
            return Err(Error::FactorialTooLarge);
        }
        Ok((1..=n).product::<u64>() as f64)
    }
    
    // è¡¨è¾¾å¼æ±‚å€¼
    pub fn evaluate_expression(&self, expression: &str) -> Result<f64, Error> {
        let tokens = self.parser.tokenize(expression)?;
        let ast = self.parser.parse(tokens)?;
        self.evaluator.evaluate(&ast)
    }
    
    // ç»Ÿè®¡è®¡ç®—
    pub fn calculate_statistics(&self, data: &[f64]) -> Result<Statistics, Error> {
        if data.is_empty() {
            return Err(Error::EmptyDataSet);
        }
        
        let n = data.len() as f64;
        let sum: f64 = data.iter().sum();
        let mean = sum / n;
        
        // è®¡ç®—æ–¹å·®
        let variance: f64 = data.iter()
            .map(|&x| (x - mean).powi(2))
            .sum::<f64>() / n;
        let std_dev = variance.sqrt();
        
        // è®¡ç®—ä¸­ä½æ•°
        let mut sorted_data = data.to_vec();
        sorted_data.sort_by(|a, b| a.partial_cmp(b).unwrap());
        let median = if n % 2.0 == 0.0 {
            (sorted_data[(n as usize / 2) - 1] + sorted_data[n as usize / 2]) / 2.0
        } else {
            sorted_data[n as usize / 2]
        };
        
        let min = data.iter().cloned().fold(f64::INFINITY, f64::min);
        let max = data.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
        
        // è®¡ç®—ä¼—æ•°
        let mut frequency = std::collections::HashMap::new();
        for &value in data {
            *frequency.entry(value).or_insert(0) += 1;
        }
        let max_count = frequency.values().max().unwrap_or(&0).clone();
        let mode: Vec<f64> = frequency
            .into_iter()
            .filter(|&(_, count)| count == max_count)
            .map(|(value, _)| value)
            .collect();
        
        Ok(Statistics {
            count: data.len(),
            mean,
            median,
            mode,
            variance,
            std_dev,
            min,
            max,
            sum,
        })
    }
}
```

### 2.7.4 è¡¨è¾¾å¼è§£æå™¨

```rust
// src/calculator/parser.rs
use crate::utils::Error;

#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Number(f64),
    Identifier(String),
    Operator(Operator),
    LParen,
    RParen,
    Comma,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Operator {
    Add,
    Subtract,
    Multiply,
    Divide,
    Power,
    Sqrt,
    Sin,
    Cos,
    Tan,
    Ln,
    Log,
    Factorial,
}

#[derive(Debug, Clone)]
pub enum AstNode {
    Number(f64),
    Identifier(String),
    UnaryOp(Operator, Box<AstNode>),
    BinaryOp(Operator, Box<AstNode>, Box<AstNode>),
    FunctionCall(String, Vec<AstNode>),
}

pub struct ExpressionParser {
    // æ“ä½œç¬¦ä¼˜å…ˆçº§
    precedence: std::collections::HashMap<Operator, i32>,
}

impl ExpressionParser {
    pub fn new() -> Self {
        let mut precedence = std::collections::HashMap::new();
        precedence.insert(Operator::Add, 1);
        precedence.insert(Operator::Subtract, 1);
        precedence.insert(Operator::Multiply, 2);
        precedence.insert(Operator::Divide, 2);
        precedence.insert(Operator::Power, 3);
        precedence.insert(Operator::Sqrt, 4);
        precedence.insert(Operator::Factorial, 5);
        precedence.insert(Operator::Sin, 6);
        precedence.insert(Operator::Cos, 6);
        precedence.insert(Operator::Tan, 6);
        precedence.insert(Operator::Ln, 6);
        precedence.insert(Operator::Log, 6);
        
        Self { precedence }
    }
    
    pub fn tokenize(&self, input: &str) -> Result<Vec<Token>, Error> {
        let mut tokens = Vec::new();
        let mut chars = input.chars().peekable();
        
        while let Some(ch) = chars.next() {
            match ch {
                '0'..='9' | '.' => {
                    let mut number_str = ch.to_string();
                    
                    // ç»§ç»­è¯»å–æ•°å­—å’Œå°æ•°ç‚¹
                    while let Some(&next_ch) = chars.peek() {
                        if next_ch.is_numeric() || next_ch == &'.' {
                            number_str.push(chars.next().unwrap());
                        } else {
                            break;
                        }
                    }
                    
                    let number: f64 = number_str.parse()
                        .map_err(|_| Error::InvalidNumber(number_str))?;
                    tokens.push(Token::Number(number));
                }
                'a'..='z' | 'A'..='Z' | '_' => {
                    let mut ident = ch.to_string();
                    
                    // ç»§ç»­è¯»å–æ ‡è¯†ç¬¦å­—ç¬¦
                    while let Some(&next_ch) = chars.peek() {
                        if next_ch.is_alphanumeric() || next_ch == &'_' {
                            ident.push(chars.next().unwrap());
                        } else {
                            break;
                        }
                    }
                    
                    tokens.push(Token::Identifier(ident));
                }
                '+' => tokens.push(Token::Operator(Operator::Add)),
                '-' => tokens.push(Token::Operator(Operator::Subtract)),
                '*' => tokens.push(Token::Operator(Operator::Multiply)),
                '/' => tokens.push(Token::Operator(Operator::Divide)),
                '^' => tokens.push(Token::Operator(Operator::Power)),
                '(' => tokens.push(Token::LParen),
                ')' => tokens.push(Token::RParen),
                ',' => tokens.push(Token::Comma),
                ' ' | '\t' | '\n' | '\r' => continue, // è·³è¿‡ç©ºç™½å­—ç¬¦
                _ => return Err(Error::InvalidCharacter(ch)),
            }
        }
        
        Ok(tokens)
    }
    
    pub fn parse(&self, tokens: Vec<Token>) -> Result<AstNode, Error> {
        let mut output = Vec::new();
        let mut operators = Vec::new();
        
        for token in tokens {
            match token {
                Token::Number(n) => output.push(AstNode::Number(n)),
                Token::Identifier(ident) => output.push(AstNode::Identifier(ident)),
                Token::Operator(op) => {
                    while let Some(Token::Operator(prev_op)) = operators.last() {
                        if self.get_precedence(prev_op) >= self.get_precedence(&op) {
                            self.pop_operator_to_output(&mut operators, &mut output)?;
                        } else {
                            break;
                        }
                    }
                    operators.push(Token::Operator(op));
                }
                Token::LParen => operators.push(token),
                Token::RParen => {
                    while let Some(op) = operators.pop() {
                        match op {
                            Token::LParen => break,
                            Token::Operator(op) => self.pop_operator_to_output(&operators, &mut output)?,
                            _ => return Err(Error::MismatchedParen),
                        }
                    }
                }
                Token::Comma => {
                    while let Some(token) = operators.pop() {
                        match token {
                            Token::LParen => return Err(Error::MismatchedParen),
                            Token::Operator(op) => self.pop_operator_to_output(&operators, &mut output)?,
                            _ => {}
                        }
                    }
                }
            }
        }
        
        while let Some(token) = operators.pop() {
            match token {
                Token::Operator(op) => self.pop_operator_to_output(&operators, &mut output)?,
                Token::LParen | Token::RParen | Token::Comma => 
                    return Err(Error::MismatchedParen),
            }
        }
        
        if output.len() != 1 {
            return Err(Error::InvalidExpression);
        }
        
        Ok(output.remove(0))
    }
    
    fn get_precedence(&self, op: &Operator) -> i32 {
        *self.precedence.get(op).unwrap_or(&0)
    }
    
    fn pop_operator_to_output(
        &self, 
        operators: &mut Vec<Token>, 
        output: &mut Vec<AstNode>
    ) -> Result<(), Error> {
        if let Some(Token::Operator(op)) = operators.pop() {
            match op {
                Operator::Sqrt | Operator::Sin | Operator::Cos | Operator::Tan 
                | Operator::Ln | Operator::Factorial => {
                    if let Some(operand) = output.pop() {
                        output.push(AstNode::UnaryOp(op, Box::new(operand)));
                    } else {
                        return Err(Error::InsufficientOperands);
                    }
                }
                _ => {
                    if let (Some(right), Some(left)) = (output.pop(), output.pop()) {
                        output.push(AstNode::BinaryOp(op, Box::new(left), Box::new(right)));
                    } else {
                        return Err(Error::InsufficientOperands);
                    }
                }
            }
        }
        Ok(())
    }
}
```

### 2.7.5 è¡¨è¾¾å¼æ±‚å€¼å™¨

```rust
// src/calculator/evaluator.rs
use super::parser::{AstNode, Operator};
use crate::utils::Error;

pub struct ExpressionEvaluator {
    functions: std::collections::HashMap<String, fn(&[f64]) -> Result<f64, Error>>,
}

impl ExpressionEvaluator {
    pub fn new() -> Self {
        let mut functions = std::collections::HashMap::new();
        
        // æ³¨å†Œå†…ç½®å‡½æ•°
        functions.insert("sqrt".to_string(), |args| {
            if args.len() != 1 {
                return Err(Error::InvalidArgumentCount("sqrt".to_string(), 1, args.len()));
            }
            if args[0] < 0.0 {
                return Err(Error::NegativeSquareRoot);
            }
            Ok(args[0].sqrt())
        });
        
        functions.insert("sin".to_string(), |args| {
            if args.len() != 1 {
                return Err(Error::InvalidArgumentCount("sin".to_string(), 1, args.len()));
            }
            Ok(args[0].sin())
        });
        
        functions.insert("cos".to_string(), |args| {
            if args.len() != 1 {
                return Err(Error::InvalidArgumentCount("cos".to_string(), 1, args.len()));
            }
            Ok(args[0].cos())
        });
        
        functions.insert("tan".to_string(), |args| {
            if args.len() != 1 {
                return Err(Error::InvalidArgumentCount("tan".to_string(), 1, args.len()));
            }
            Ok(args[0].tan())
        });
        
        functions.insert("ln".to_string(), |args| {
            if args.len() != 1 {
                return Err(Error::InvalidArgumentCount("ln".to_string(), 1, args.len()));
            }
            if args[0] <= 0.0 {
                return Err(Error::InvalidLogarithm);
            }
            Ok(args[0].ln())
        });
        
        functions.insert("log".to_string(), |args| {
            if args.len() != 2 {
                return Err(Error::InvalidArgumentCount("log".to_string(), 2, args.len()));
            }
            if args[0] <= 0.0 || args[1] <= 0.0 || args[1] == 1.0 {
                return Err(Error::InvalidLogarithm);
            }
            Ok(args[0].log(args[1]))
        });
        
        functions.insert("factorial".to_string(), |args| {
            if args.len() != 1 {
                return Err(Error::InvalidArgumentCount("factorial".to_string(), 1, args.len()));
            }
            let n = args[0] as u64;
            if args[0] < 0.0 || args[0] - n as f64 != 0.0 {
                return Err(Error::InvalidFactorialArgument);
            }
            if n > 20 {
                return Err(Error::FactorialTooLarge);
            }
            Ok((1..=n).product::<u64>() as f64)
        });
        
        Self { functions }
    }
    
    pub fn evaluate(&self, ast: &AstNode) -> Result<f64, Error> {
        match ast {
            AstNode::Number(n) => Ok(*n),
            AstNode::Identifier(ident) => {
                // å¤„ç†å¸¸é‡å’Œå˜é‡
                match ident.as_str() {
                    "pi" => Ok(std::f64::consts::PI),
                    "e" => Ok(std::f64::consts::E),
                    _ => Err(Error::UndefinedVariable(ident.clone())),
                }
            }
            AstNode::UnaryOp(op, operand) => {
                let value = self.evaluate(operand)?;
                self.evaluate_unary_op(*op, value)
            }
            AstNode::BinaryOp(op, left, right) => {
                let left_val = self.evaluate(left)?;
                let right_val = self.evaluate(right)?;
                self.evaluate_binary_op(*op, left_val, right_val)
            }
            AstNode::FunctionCall(name, args) => {
                let arg_values: Result<Vec<f64>, _> = 
                    args.iter().map(|arg| self.evaluate(arg)).collect();
                let arg_values = arg_values?;
                
                if let Some(func) = self.functions.get(name) {
                    func(&arg_values)
                } else {
                    Err(Error::UndefinedFunction(name.clone()))
                }
            }
        }
    }
    
    fn evaluate_unary_op(&self, op: Operator, value: f64) -> Result<f64, Error> {
        match op {
            Operator::Sqrt => {
                if value < 0.0 {
                    Err(Error::NegativeSquareRoot)
                } else {
                    Ok(value.sqrt())
                }
            }
            Operator::Sin => Ok(value.sin()),
            Operator::Cos => Ok(value.cos()),
            Operator::Tan => Ok(value.tan()),
            Operator::Ln => {
                if value <= 0.0 {
                    Err(Error::InvalidLogarithm)
                } else {
                    Ok(value.ln())
                }
            }
            Operator::Factorial => {
                if value < 0.0 || value.fract() != 0.0 {
                    return Err(Error::InvalidFactorialArgument);
                }
                let n = value as u64;
                if n > 20 {
                    return Err(Error::FactorialTooLarge);
                }
                Ok((1..=n).product::<u64>() as f64)
            }
            _ => Err(Error::InvalidOperator),
        }
    }
    
    fn evaluate_binary_op(&self, op: Operator, left: f64, right: f64) -> Result<f64, Error> {
        match op {
            Operator::Add => Ok(left + right),
            Operator::Subtract => Ok(left - right),
            Operator::Multiply => Ok(left * right),
            Operator::Divide => {
                if right == 0.0 {
                    Err(Error::DivisionByZero)
                } else {
                    Ok(left / right)
                }
            }
            Operator::Power => Ok(left.powf(right)),
            _ => Err(Error::InvalidOperator),
        }
    }
}
```

### 2.7.6 æ•°æ®ç»Ÿè®¡æ¨¡å—

```rust
// src/data/mod.rs
pub mod types;
pub mod statistics;

use types::Statistics;

// é‡æ–°å¯¼å‡º
pub use statistics::Statistics;
```

```rust
// src/data/statistics.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Statistics {
    pub count: usize,
    pub mean: f64,
    pub median: f64,
    pub mode: Vec<f64>,
    pub variance: f64,
    pub std_dev: f64,
    pub min: f64,
    pub max: f64,
    pub sum: f64,
}

impl Statistics {
    pub fn print_detailed(&self) {
        println!("=== ç»Ÿè®¡ä¿¡æ¯ ===");
        println!("æ•°æ®ä¸ªæ•°: {}", self.count);
        println!("æ€»å’Œ: {:.2}", self.sum);
        println!("å¹³å‡å€¼: {:.2}", self.mean);
        println!("ä¸­ä½æ•°: {:.2}", self.median);
        println!("ä¼—æ•°: {:?}", self.mode.iter()
            .map(|&x| format!("{:.2}", x))
            .collect::<Vec<_>>()
            .join(", "));
        println!("æœ€å°å€¼: {:.2}", self.min);
        println!("æœ€å¤§å€¼: {:.2}", self.max);
        println!("æ–¹å·®: {:.4}", self.variance);
        println!("æ ‡å‡†å·®: {:.4}", self.std_dev);
        println!("===============");
    }
    
    pub fn get_range(&self) -> f64 {
        self.max - self.min
    }
    
    pub fn get_coefficient_of_variation(&self) -> f64 {
        if self.mean == 0.0 {
            0.0
        } else {
            self.std_dev / self.mean.abs()
        }
    }
}

// çº¿æ€§å›å½’
pub struct LinearRegression {
    pub slope: f64,
    pub intercept: f64,
    pub r_squared: f64,
}

impl LinearRegression {
    pub fn new(x_data: &[f64], y_data: &[f64]) -> Option<Self> {
        if x_data.len() != y_data.len() || x_data.is_empty() {
            return None;
        }
        
        let n = x_data.len() as f64;
        let sum_x: f64 = x_data.iter().sum();
        let sum_y: f64 = y_data.iter().sum();
        let sum_xy: f64 = x_data.iter().zip(y_data.iter())
            .map(|(&x, &y)| x * y).sum();
        let sum_x2: f64 = x_data.iter().map(|&x| x * x).sum();
        let sum_y2: f64 = y_data.iter().map(|&y| y * y).sum();
        
        let slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);
        let intercept = (sum_y - slope * sum_x) / n;
        
        // è®¡ç®— RÂ²
        let ss_tot: f64 = y_data.iter()
            .map(|&y| (y - sum_y / n).powi(2))
            .sum();
        let ss_res: f64 = x_data.iter().zip(y_data.iter())
            .map(|(&x, &y)| {
                let predicted = slope * x + intercept;
                (y - predicted).powi(2)
            })
            .sum();
        let r_squared = 1.0 - (ss_res / ss_tot);
        
        Some(Self {
            slope,
            intercept,
            r_squared,
        })
    }
    
    pub fn predict(&self, x: f64) -> f64 {
        self.slope * x + self.intercept
    }
    
    pub fn print_equation(&self) {
        println!("çº¿æ€§å›å½’æ–¹ç¨‹: y = {:.4}x + {:.4}", self.slope, self.intercept);
        println!("å†³å®šç³»æ•° (RÂ²): {:.4}", self.r_squared);
    }
}
```

### 2.7.7 å†å²è®°å½•ç®¡ç†

```rust
// src/history/mod.rs
use serde::{Deserialize, Serialize};
use std::fs::{self, File};
use std::io::{self, BufRead, BufReader, Write};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryRecord {
    pub expression: String,
    pub result: f64,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

pub struct HistoryManager {
    records: Vec<HistoryRecord>,
    max_records: usize,
}

impl HistoryManager {
    pub fn new() -> Self {
        Self::with_capacity(100)
    }
    
    pub fn with_capacity(capacity: usize) -> Self {
        let records = Self::load_from_file().unwrap_or_default();
        Self {
            records,
            max_records: capacity,
        }
    }
    
    pub fn add_record(&mut self, expression: &str, result: f64) {
        let record = HistoryRecord {
            expression: expression.to_string(),
            result,
            timestamp: chrono::Utc::now(),
        };
        
        self.records.push(record);
        
        // ä¿æŒè®°å½•æ•°é‡é™åˆ¶
        if self.records.len() > self.max_records {
            self.records.remove(0);
        }
        
        // ä¿å­˜åˆ°æ–‡ä»¶
        self.save_to_file().ok();
    }
    
    pub fn get_recent_records(&self, count: usize) -> &[HistoryRecord] {
        let start = if self.records.len() > count {
            self.records.len() - count
        } else {
            0
        };
        &self.records[start..]
    }
    
    pub fn search_records(&self, query: &str) -> Vec<&HistoryRecord> {
        self.records
            .iter()
            .filter(|record| 
                record.expression.contains(query) ||
                record.result.to_string().contains(query)
            )
            .collect()
    }
    
    pub fn clear(&mut self) {
        self.records.clear();
        self.save_to_file().ok();
    }
    
    pub fn display(&self) {
        if self.records.is_empty() {
            println!("æš‚æ— è®¡ç®—å†å²");
            return;
        }
        
        println!("=== è®¡ç®—å†å² ===");
        for (i, record) in self.records.iter().enumerate() {
            println!("{}. {} = {}", 
                i + 1, 
                record.expression, 
                record.result
            );
        }
        println!("===============");
    }
    
    fn get_history_file() -> std::path::PathBuf {
        let mut path = dirs::home_dir().unwrap_or_default();
        path.push(".rust_calculator_history.json");
        path
    }
    
    fn load_from_file() -> io::Result<Vec<HistoryRecord>> {
        let path = Self::get_history_file();
        if !path.exists() {
            return Ok(Vec::new());
        }
        
        let file = File::open(path)?;
        let reader = BufReader::new(file);
        
        let records: Vec<HistoryRecord> = serde_json::from_reader(reader)
            .unwrap_or_default();
        
        Ok(records)
    }
    
    fn save_to_file(&self) -> io::Result<()> {
        let path = Self::get_history_file();
        
        // ç¡®ä¿ç›®å½•å­˜åœ¨
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }
        
        let file = File::create(path)?;
        serde_json::to_writer_pretty(file, &self.records)?;
        
        Ok(())
    }
}
```

### 2.7.8 é”™è¯¯å¤„ç†

```rust
// src/utils/mod.rs
pub mod error;

pub use error::Error;
```

```rust
// src/utils/error.rs
use serde::{Deserialize, Serialize};

#[derive(Debug, thiserror::Error, Serialize, Deserialize)]
pub enum Error {
    #[error("é™¤é›¶é”™è¯¯")]
    DivisionByZero,
    
    #[error("è´Ÿæ•°å¼€å¹³æ–¹æ ¹: {0}")]
    NegativeSquareRoot,
    
    #[error("æ— æ•ˆçš„å¯¹æ•°: åº•æ•°å¿…é¡» > 0 ä¸” â‰  1, çœŸæ•°å¿…é¡» > 0")]
    InvalidLogarithm,
    
    #[error("é˜¶ä¹˜å‚æ•°æ— æ•ˆ: å¿…é¡»æ˜¯éè´Ÿæ•´æ•°")]
    InvalidFactorialArgument,
    
    #[error("é˜¶ä¹˜å€¼è¿‡å¤§: n > 20")]
    FactorialTooLarge,
    
    #[error("ç©ºæ•°æ®é›†")]
    EmptyDataSet,
    
    #[error("æ— æ•ˆæ•°å­—: {0}")]
    InvalidNumber(String),
    
    #[error("æ— æ•ˆå­—ç¬¦: {0}")]
    InvalidCharacter(char),
    
    #[error("æ‹¬å·ä¸åŒ¹é…")]
    MismatchedParen,
    
    #[error("æ— æ•ˆè¡¨è¾¾å¼")]
    InvalidExpression,
    
    #[error("æ“ä½œæ•°ä¸è¶³")]
    InsufficientOperands,
    
    #[error("æ— æ•ˆæ“ä½œç¬¦")]
    InvalidOperator,
    
    #[error("æœªå®šä¹‰å˜é‡: {0}")]
    UndefinedVariable(String),
    
    #[error("æœªå®šä¹‰å‡½æ•°: {0}")]
    UndefinedFunction(String),
    
    #[error("å‡½æ•° {0} å‚æ•°æ•°é‡é”™è¯¯: æœŸæœ› {1}, å®é™… {2}")]
    InvalidArgumentCount(String, usize, usize),
    
    #[error("è¾“å…¥/è¾“å‡ºé”™è¯¯: {0}")]
    Io(#[from] std::io::Error),
    
    #[error("JSON åºåˆ—åŒ–é”™è¯¯: {0}")]
    Json(#[from] serde_json::Error),
    
    #[error("æ—¶é—´å¤„ç†é”™è¯¯: {0}")]
    Chrono(#[from] chrono::ParseError),
}
```

---

## 2.8 ç»ƒä¹ é¢˜

### ç»ƒä¹  2.1ï¼šåŸºç¡€è®¡ç®—å™¨

å®ç°ä¸€ä¸ªåŸºç¡€çš„å››åˆ™è¿ç®—è®¡ç®—å™¨ï¼š

- æ”¯æŒ +ã€-ã€*ã€/ æ“ä½œ
- å¤„ç†é”™è¯¯æƒ…å†µï¼ˆé™¤é›¶ç­‰ï¼‰
- æä¾›ç”¨æˆ·å‹å¥½çš„ç•Œé¢

### ç»ƒä¹  2.2ï¼šæ¸©åº¦è½¬æ¢å™¨

åˆ›å»ºä¸€ä¸ªæ¸©åº¦è½¬æ¢å·¥å…·ï¼š

- æ‘„æ°åº¦ â†” åæ°åº¦
- æ‘„æ°åº¦ â†” å¼€å°”æ–‡
- æ”¯æŒæ‰¹é‡è½¬æ¢
- æ˜¾ç¤ºè½¬æ¢å†å²

### ç»ƒä¹  2.3ï¼šæ•°æ®åˆ†æå·¥å…·

å¼€å‘ä¸€ä¸ªç®€å•æ•°æ®å¤„ç†å™¨ï¼š

- è¯»å– CSV æ–‡ä»¶
- è®¡ç®—åŸºç¡€ç»Ÿè®¡é‡
- æ‰¾å‡ºæå€¼å’Œå¼‚å¸¸å€¼
- ç”ŸæˆæŠ¥å‘Š

### ç»ƒä¹  2.4ï¼šå•ä½è½¬æ¢å™¨

è®¾è®¡ä¸€ä¸ªå•ä½è½¬æ¢ç³»ç»Ÿï¼š

- é•¿åº¦å•ä½è½¬æ¢ï¼ˆç±³ã€å˜ç±³ã€è‹±å°ºç­‰ï¼‰
- é‡é‡å•ä½è½¬æ¢ï¼ˆå…¬æ–¤ã€ç£…ã€ç›å¸ç­‰ï¼‰
- æ¸©åº¦å•ä½è½¬æ¢
- è‡ªå®šä¹‰è½¬æ¢å‡½æ•°

### ç»ƒä¹  2.5ï¼šå…ƒç»„æ•°æ®å¤„ç†å™¨

åˆ›å»ºä¸€ä¸ªå¤„ç†å…ƒç»„æ•°æ®çš„å·¥å…·ï¼š

- è§£æåŒ…å«å§“åã€å¹´é¾„ã€æˆç»©çš„å­¦ç”Ÿä¿¡æ¯
- å®ç°åæ ‡å‡ ä½•è®¡ç®—ï¼ˆç‚¹è·ç¦»ã€ä¸­ç‚¹ç­‰ï¼‰
- æ—¶é—´å¤„ç†ï¼ˆå°æ—¶ã€åˆ†é’Ÿã€ç§’çš„è½¬æ¢ï¼‰
- å¤šå€¼è¿”å›å‡½æ•°çš„ç»ƒä¹ 

### ç»ƒä¹  2.6ï¼šæ•°ç»„æ•°æ®åˆ†æå™¨

å¼€å‘ä¸€ä¸ªæ•°ç»„æ•°æ®å¤„ç†ç¨‹åºï¼š

- æ•°ç»„çš„æ’åºã€æœç´¢å’Œç»Ÿè®¡åˆ†æ
- å¤šç»´æ•°ç»„æ“ä½œï¼ˆçŸ©é˜µè¿ç®—ï¼‰
- æ•°ç»„å…ƒç´ çš„æ›¿æ¢å’Œåˆ é™¤
- å®ç°ç»å…¸ç®—æ³•ï¼ˆå†’æ³¡æ’åºã€äºŒåˆ†æŸ¥æ‰¾ç­‰ï¼‰

---

## 2.9 æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 2.9.1 æ•°å€¼è®¡ç®—ä¼˜åŒ–

```rust
// é¿å…é‡å¤è®¡ç®—
fn optimized_calculation(data: &[f64]) -> (f64, f64) {
    let n = data.len() as f64;
    let sum: f64 = data.iter().sum();
    let mean = sum / n;
    
    // ä¸€æ¬¡éå†è®¡ç®—æ–¹å·®
    let variance: f64 = data.iter()
        .map(|&x| (x - mean).powi(2))
        .sum::<f64>() / n;
    
    let std_dev = variance.sqrt();
    (mean, std_dev)
}

// ä½¿ç”¨è¿­ä»£å™¨ä¼˜åŒ–
fn iterator_optimization() {
    let numbers: Vec<i32> = (1..=1000).collect();
    
    // é“¾å¼æ“ä½œ
    let result: i32 = numbers
        .iter()
        .filter(|&&x| x % 2 == 0)    // è¿‡æ»¤å¶æ•°
        .map(|&x| x * x)             // å¹³æ–¹
        .sum();                      // æ±‚å’Œ
    
    println!("å¶æ•°å¹³æ–¹å’Œ: {}", result);
}
```

### 2.9.2 å†…å­˜ç®¡ç†ä¼˜åŒ–

```rust
// é¢„åˆ†é…å®¹é‡
fn preallocate_example() {
    let mut numbers = Vec::with_capacity(1000);
    for i in 0..1000 {
        numbers.push(i);
    }
}

// é¿å…ä¸å¿…è¦çš„å…‹éš†
fn efficient_cloning() {
    let original = vec![1, 2, 3, 4, 5];
    
    // ä½¿ç”¨å¼•ç”¨è€Œä¸æ˜¯å…‹éš†
    let sum: i32 = original.iter().sum();
    
    // åªåœ¨éœ€è¦æ—¶å…‹éš†
    if sum > 10 {
        let cloned = original.clone();  // å¿…è¦æ—¶æ‰å…‹éš†
        // ä½¿ç”¨ cloned
    }
}
```

---

## 2.10 æœ¬ç« æ€»ç»“

é€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ å·²ç»æŒæ¡äº†ï¼š

### æ ¸å¿ƒæ¦‚å¿µ

1. **å˜é‡å£°æ˜**ï¼šletã€let mutã€const çš„ä½¿ç”¨å’ŒåŒºåˆ«
2. **åŸºç¡€æ•°æ®ç±»å‹**ï¼šæ•´æ•°ã€æµ®ç‚¹ã€å¸ƒå°”ã€å­—ç¬¦ã€å­—ç¬¦ä¸²
3. **å¤åˆæ•°æ®ç±»å‹**ï¼šå…ƒç»„ï¼ˆä¸åŒç±»å‹å…ƒç´ çš„å›ºå®šé›†åˆï¼‰ã€æ•°ç»„ï¼ˆç›¸åŒç±»å‹å…ƒç´ çš„å›ºå®šé›†åˆï¼‰
4. **æ§åˆ¶æµ**ï¼šifã€loopã€whileã€forã€match
5. **å‡½æ•°**ï¼šå®šä¹‰ã€è°ƒç”¨ã€å‚æ•°ã€è¿”å›å€¼

### å®æˆ˜é¡¹ç›®

- å®Œæ•´çš„ç§‘å­¦è®¡ç®—å™¨å®ç°
- è¡¨è¾¾å¼è§£æå’Œæ±‚å€¼
- æ•°æ®ç»Ÿè®¡åˆ†æåŠŸèƒ½
- å†å²è®°å½•ç®¡ç†

### æœ€ä½³å®è·µ

- å˜é‡å‘½åè§„èŒƒ
- é”™è¯¯å¤„ç†ç­–ç•¥
- æ€§èƒ½ä¼˜åŒ–æŠ€å·§
- ä»£ç ç»„ç»‡æ–¹å¼

### ä¸‹ä¸€ç« é¢„å‘Š

- æ‰€æœ‰æƒå’Œå€Ÿç”¨ç³»ç»Ÿ
- å†…å­˜å®‰å…¨ä¿è¯
- å¼•ç”¨å’Œåˆ‡ç‰‡
- ç”Ÿå‘½å‘¨æœŸæ¦‚å¿µ

---

**é€šè¿‡è¿™äº›åŸºç¡€çŸ¥è¯†çš„æŒæ¡å’Œå®é™…é¡¹ç›®çš„ç»ƒä¹ ï¼Œä½ å·²ç»å…·å¤‡äº† Rust ç¼–ç¨‹çš„åŸºæœ¬èƒ½åŠ›ã€‚æ¥ä¸‹æ¥å°†æ·±å…¥å­¦ä¹  Rust æœ€å…·ç‰¹è‰²çš„æ‰€æœ‰æƒç³»ç»Ÿï¼**
